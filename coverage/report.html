
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/umatare5/cisco-ios-xe-wireless-go/internal/core/client.go (87.4%)</option>
				
				<option value="file1">github.com/umatare5/cisco-ios-xe-wireless-go/internal/core/errors.go (100.0%)</option>
				
				<option value="file2">github.com/umatare5/cisco-ios-xe-wireless-go/internal/core/request.go (93.3%)</option>
				
				<option value="file3">github.com/umatare5/cisco-ios-xe-wireless-go/internal/core/wireless.go (100.0%)</option>
				
				<option value="file4">github.com/umatare5/cisco-ios-xe-wireless-go/internal/errors/service.go (100.0%)</option>
				
				<option value="file5">github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/builder.go (100.0%)</option>
				
				<option value="file6">github.com/umatare5/cisco-ios-xe-wireless-go/internal/service/base.go (100.0%)</option>
				
				<option value="file7">github.com/umatare5/cisco-ios-xe-wireless-go/internal/testutil/helper.go (60.9%)</option>
				
				<option value="file8">github.com/umatare5/cisco-ios-xe-wireless-go/internal/transport/client.go (91.8%)</option>
				
				<option value="file9">github.com/umatare5/cisco-ios-xe-wireless-go/internal/transport/transport.go (100.0%)</option>
				
				<option value="file10">github.com/umatare5/cisco-ios-xe-wireless-go/internal/validation/validation.go (95.8%)</option>
				
				<option value="file11">github.com/umatare5/cisco-ios-xe-wireless-go/pkg/testutil/context.go (100.0%)</option>
				
				<option value="file12">github.com/umatare5/cisco-ios-xe-wireless-go/pkg/testutil/mock.go (94.3%)</option>
				
				<option value="file13">github.com/umatare5/cisco-ios-xe-wireless-go/pkg/testutil/testing.go (88.9%)</option>
				
				<option value="file14">github.com/umatare5/cisco-ios-xe-wireless-go/service/afc/service.go (100.0%)</option>
				
				<option value="file15">github.com/umatare5/cisco-ios-xe-wireless-go/service/ap/service.go (92.2%)</option>
				
				<option value="file16">github.com/umatare5/cisco-ios-xe-wireless-go/service/apf/service.go (100.0%)</option>
				
				<option value="file17">github.com/umatare5/cisco-ios-xe-wireless-go/service/awips/service.go (100.0%)</option>
				
				<option value="file18">github.com/umatare5/cisco-ios-xe-wireless-go/service/ble/service.go (100.0%)</option>
				
				<option value="file19">github.com/umatare5/cisco-ios-xe-wireless-go/service/client/service.go (100.0%)</option>
				
				<option value="file20">github.com/umatare5/cisco-ios-xe-wireless-go/service/controller/service.go (100.0%)</option>
				
				<option value="file21">github.com/umatare5/cisco-ios-xe-wireless-go/service/cts/service.go (100.0%)</option>
				
				<option value="file22">github.com/umatare5/cisco-ios-xe-wireless-go/service/dot11/service.go (100.0%)</option>
				
				<option value="file23">github.com/umatare5/cisco-ios-xe-wireless-go/service/dot15/service.go (100.0%)</option>
				
				<option value="file24">github.com/umatare5/cisco-ios-xe-wireless-go/service/fabric/service.go (100.0%)</option>
				
				<option value="file25">github.com/umatare5/cisco-ios-xe-wireless-go/service/flex/service.go (100.0%)</option>
				
				<option value="file26">github.com/umatare5/cisco-ios-xe-wireless-go/service/general/service.go (100.0%)</option>
				
				<option value="file27">github.com/umatare5/cisco-ios-xe-wireless-go/service/geolocation/service.go (100.0%)</option>
				
				<option value="file28">github.com/umatare5/cisco-ios-xe-wireless-go/service/hyperlocation/service.go (100.0%)</option>
				
				<option value="file29">github.com/umatare5/cisco-ios-xe-wireless-go/service/lisp/service.go (100.0%)</option>
				
				<option value="file30">github.com/umatare5/cisco-ios-xe-wireless-go/service/location/service.go (100.0%)</option>
				
				<option value="file31">github.com/umatare5/cisco-ios-xe-wireless-go/service/mcast/service.go (100.0%)</option>
				
				<option value="file32">github.com/umatare5/cisco-ios-xe-wireless-go/service/mdns/service.go (100.0%)</option>
				
				<option value="file33">github.com/umatare5/cisco-ios-xe-wireless-go/service/mesh/service.go (100.0%)</option>
				
				<option value="file34">github.com/umatare5/cisco-ios-xe-wireless-go/service/mobility/service.go (100.0%)</option>
				
				<option value="file35">github.com/umatare5/cisco-ios-xe-wireless-go/service/nmsp/service.go (100.0%)</option>
				
				<option value="file36">github.com/umatare5/cisco-ios-xe-wireless-go/service/radio/service.go (100.0%)</option>
				
				<option value="file37">github.com/umatare5/cisco-ios-xe-wireless-go/service/rf/service.go (100.0%)</option>
				
				<option value="file38">github.com/umatare5/cisco-ios-xe-wireless-go/service/rf/tag_service.go (90.8%)</option>
				
				<option value="file39">github.com/umatare5/cisco-ios-xe-wireless-go/service/rfid/service.go (100.0%)</option>
				
				<option value="file40">github.com/umatare5/cisco-ios-xe-wireless-go/service/rogue/service.go (100.0%)</option>
				
				<option value="file41">github.com/umatare5/cisco-ios-xe-wireless-go/service/rrm/service.go (100.0%)</option>
				
				<option value="file42">github.com/umatare5/cisco-ios-xe-wireless-go/service/site/service.go (100.0%)</option>
				
				<option value="file43">github.com/umatare5/cisco-ios-xe-wireless-go/service/site/tag_service.go (92.1%)</option>
				
				<option value="file44">github.com/umatare5/cisco-ios-xe-wireless-go/service/spaces/service.go (100.0%)</option>
				
				<option value="file45">github.com/umatare5/cisco-ios-xe-wireless-go/service/urwb/service.go (100.0%)</option>
				
				<option value="file46">github.com/umatare5/cisco-ios-xe-wireless-go/service/wat/service.go (100.0%)</option>
				
				<option value="file47">github.com/umatare5/cisco-ios-xe-wireless-go/service/wlan/service.go (100.0%)</option>
				
				<option value="file48">github.com/umatare5/cisco-ios-xe-wireless-go/service/wlan/tag_service.go (91.3%)</option>
				
				<option value="file49">github.com/umatare5/cisco-ios-xe-wireless-go/wnc.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package core

import (
        "context"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "time"

        ierrors "github.com/umatare5/cisco-ios-xe-wireless-go/internal/errors"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/transport"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/validation"
)

// Default timeout constant.
const (
        // DefaultTimeout is the default timeout for API requests.
        DefaultTimeout = 60 * time.Second
)

// Client represents the core WNC API client with connection pooling and structured logging.
type Client struct {
        httpClient     *http.Client              // Reused HTTP client with connection pool
        rest           *restconf.Builder         // RESTCONF URL builder
        logger         *slog.Logger              // Structured logger
        token          string                    // Access token for authorization
        requestBuilder *transport.RequestBuilder // HTTP request builder
}

// Option represents a functional option for configuring the Client.
type Option func(*Client) error

// WithTimeout sets the timeout duration for HTTP requests.
func WithTimeout(timeout time.Duration) Option <span class="cov5" title="5">{
        return func(c *Client) error </span><span class="cov5" title="5">{
                if !validation.IsValidTimeout(timeout) </span><span class="cov2" title="2">{
                        return fmt.Errorf("client configuration failed: %w",
                                fmt.Errorf("timeout validation failed: timeout must be positive, got %v", timeout))
                }</span>
                <span class="cov3" title="3">c.httpClient.Timeout = timeout
                return nil</span>
        }
}

// WithInsecureSkipVerify configures TLS certificate verification.
func WithInsecureSkipVerify(skip bool) Option <span class="cov7" title="11">{
        return func(c *Client) error </span><span class="cov7" title="11">{
                c.httpClient.Transport = transport.NewTransport(skip)
                return nil
        }</span>
}

// WithLogger sets a custom logger for the client.
func WithLogger(logger *slog.Logger) Option <span class="cov1" title="1">{
        return func(c *Client) error </span><span class="cov1" title="1">{
                if logger == nil </span><span class="cov1" title="1">{
                        return errors.New("logger cannot be nil")
                }</span>
                <span class="cov0" title="0">c.logger = logger
                return nil</span>
        }
}

// WithUserAgent sets a custom User-Agent header.
func WithUserAgent(userAgent string) Option <span class="cov1" title="1">{
        return func(c *Client) error </span><span class="cov1" title="1">{
                // This will be handled in the headers when making requests
                // For now, we store it in the client context (not implemented yet)
                return nil
        }</span>
}

// New creates a new WNC client with the specified host, token, and options.
func New(host, token string, opts ...Option) (*Client, error) <span class="cov9" title="25">{
        // Validate inputs using existing validation functions
        if !validation.IsValidController(host) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("client initialization failed: %w",
                        fmt.Errorf("controller address validation failed: invalid format %s", host))
        }</span>
        <span class="cov9" title="24">if !validation.IsValidAccessToken(token) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("client initialization failed: %w",
                        errors.New("access token validation failed: token is empty or invalid format"))
        }</span>

        // Create HTTP client with transport
        <span class="cov9" title="23">httpClient := &amp;http.Client{
                Transport: transport.NewTransport(false), // Default to secure
                Timeout:   DefaultTimeout,
        }

        // Create RESTCONF URL builder
        restBuilder := restconf.NewBuilder(restconf.DefaultProtocol, host)

        // Create client with defaults
        client := &amp;Client{
                httpClient: httpClient,
                rest:       restBuilder,
                logger:     slog.Default(),
                token:      token,
        }

        // Initialize request builder
        client.requestBuilder = transport.NewRequestBuilder(restBuilder, token, client.logger)

        // Apply options
        for _, opt := range opts </span><span class="cov8" title="18">{
                if err := opt(client); err != nil </span><span class="cov3" title="3">{
                        return nil, fmt.Errorf("failed to apply option: %w", err)
                }</span>
        }

        <span class="cov8" title="20">return client, nil</span>
}

// Do executes an HTTP request and returns the response body.
func (c *Client) Do(ctx context.Context, method, path string) ([]byte, error) <span class="cov7" title="13">{
        if err := c.validateDoParameters(ctx); err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov7" title="11">req, err := c.requestBuilder.CreateRequest(ctx, method, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="11">resp, err := c.requestBuilder.ExecuteRequest(c.httpClient, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov7" title="10">defer c.closeResponseBody(resp)

        body, err := c.readResponseBody(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Early return for HTTP errors
        <span class="cov7" title="10">if err := c.checkHTTPErrors(resp, body); err != nil </span><span class="cov5" title="5">{
                return nil, err
        }</span>

        <span class="cov5" title="5">c.logger.Debug("Successfully processed API response", "path", path)
        return body, nil</span>
}

// DoWithPayload performs an HTTP request with a payload and returns the response body.
func (c *Client) DoWithPayload(ctx context.Context, method, path string, payload any) ([]byte, error) <span class="cov7" title="12">{
        if err := c.validateDoParameters(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="12">req, err := c.requestBuilder.CreateRequestWithPayload(ctx, method, path, payload)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="11">resp, err := c.requestBuilder.ExecuteRequest(c.httpClient, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov7" title="10">defer c.closeResponseBody(resp)

        body, err := c.readResponseBody(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="10">if err := c.checkHTTPErrors(resp, body); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="10">c.logger.Debug("Successfully processed API response", "path", path)
        return body, nil</span>
}

// DoRPCWithPayload performs an HTTP RPC request with a payload and returns the response body.
func (c *Client) DoRPCWithPayload(ctx context.Context, method, rpcPath string, payload any) ([]byte, error) <span class="cov4" title="4">{
        if err := c.validateDoParameters(ctx); err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov2" title="2">req, err := c.requestBuilder.CreateRPCRequestWithPayload(ctx, method, rpcPath, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">resp, err := c.requestBuilder.ExecuteRequest(c.httpClient, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer c.closeResponseBody(resp)

        body, err := c.readResponseBody(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if err := c.checkHTTPErrors(resp, body); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">c.logger.Debug("Successfully processed RPC response", "rpcPath", rpcPath)
        return body, nil</span>
}

// validateDoParameters validates input parameters for the Do method.
func (c *Client) validateDoParameters(ctx context.Context) error <span class="cov10" title="30">{
        if c == nil </span><span class="cov2" title="2">{
                return errors.New(ierrors.ErrClientNil)
        }</span>
        <span class="cov9" title="28">if ctx == nil </span><span class="cov3" title="3">{
                return errors.New("context cannot be nil")
        }</span>
        <span class="cov9" title="25">return nil</span>
}

// closeResponseBody safely closes the response body with error logging.
func (c *Client) closeResponseBody(resp *http.Response) <span class="cov9" title="22">{
        if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov1" title="1">{
                c.logger.Error("Failed to close response body", "error", closeErr)
        }</span>
}

// readResponseBody reads the complete response body.
func (c *Client) readResponseBody(resp *http.Response) ([]byte, error) <span class="cov9" title="21">{
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to read response body", "error", err)
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov9" title="21">c.logger.Debug("Received API response", "status", resp.StatusCode, "content_length", len(body))
        return body, nil</span>
}

// checkHTTPErrors validates HTTP status codes and returns appropriate errors.
func (c *Client) checkHTTPErrors(resp *http.Response, body []byte) error <span class="cov9" title="21">{
        if resp.StatusCode &gt;= http.StatusBadRequest </span><span class="cov5" title="5">{
                c.logger.Error("HTTP error response", "status", resp.StatusCode, "body", string(body))
                return &amp;APIError{
                        StatusCode: resp.StatusCode,
                        Message:    string(body),
                        Body:       body,
                }
        }</span>
        <span class="cov8" title="16">return nil</span>
}

// RESTCONFBuilder returns the RESTCONF URL builder for the client.
func (c *Client) RESTCONFBuilder() *restconf.Builder <span class="cov2" title="2">{
        if c == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return c.rest</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package core

import (
        "errors"
        "fmt"
        "net/http"
        "strings"
)

// HTTP status code constants.
const (
        // Success status codes.
        StatusOK = http.StatusOK

        // Client error status codes.
        StatusBadRequest          = http.StatusBadRequest
        StatusUnauthorized        = http.StatusUnauthorized
        StatusForbidden           = http.StatusForbidden
        StatusNotFound            = http.StatusNotFound
        StatusMethodNotAllowed    = http.StatusMethodNotAllowed
        StatusConflict            = http.StatusConflict
        StatusUnprocessableEntity = http.StatusUnprocessableEntity

        // Server error status codes.
        StatusInternalServerError = http.StatusInternalServerError
        StatusBadGateway          = http.StatusBadGateway
        StatusServiceUnavailable  = http.StatusServiceUnavailable
        StatusGatewayTimeout      = http.StatusGatewayTimeout
)

// Custom error types for better error handling and debugging.
var (
        // ErrAuthenticationFailed indicates that authentication with the WNC failed due to invalid credentials.
        ErrAuthenticationFailed = errors.New("authentication failed: invalid credentials")
        // ErrAccessForbidden indicates that the client lacks sufficient permissions for the requested operation.
        ErrAccessForbidden = errors.New("access forbidden: insufficient permissions")
        // ErrResourceNotFound indicates that the requested resource or endpoint was not found.
        ErrResourceNotFound = errors.New("resource not found")
        // ErrInvalidConfiguration indicates that the client configuration is invalid or incomplete.
        ErrInvalidConfiguration = errors.New("invalid client configuration")
        // ErrRequestTimeout indicates that the request exceeded the configured timeout period.
        ErrRequestTimeout = errors.New("request timeout")
)

// HTTPError represents an HTTP error response from the API.
type HTTPError struct {
        Status int
        Body   []byte
}

func (e *HTTPError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("HTTP %d: %s", e.Status, string(e.Body))
}</span>

// APIError represents an API-specific error with HTTP status code and message.
type APIError struct {
        StatusCode int    `json:"status_code"`
        Message    string `json:"message"`
        Body       []byte `json:"-"`
}

func (e *APIError) Error() string <span class="cov6" title="4">{
        return fmt.Sprintf("API error (HTTP %d): %s", e.StatusCode, e.Message)
}</span>

// IsNotFoundError checks if the error is a 404 not found error.
func IsNotFoundError(err error) bool <span class="cov10" title="10">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov9" title="9">var httpErr *HTTPError
        if errors.As(err, &amp;httpErr) </span><span class="cov3" title="2">{
                return httpErr.Status == http.StatusNotFound
        }</span>

        <span class="cov8" title="7">var apiErr *APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov3" title="2">{
                return apiErr.StatusCode == http.StatusNotFound
        }</span>

        <span class="cov7" title="5">errStr := err.Error()
        return strings.Contains(errStr, "404") ||
                strings.Contains(errStr, "not found") ||
                strings.Contains(errStr, "Not Found")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        ierrors "github.com/umatare5/cisco-ios-xe-wireless-go/internal/errors"
)

// Generic HTTP Operation Functions for Service Layer
// These functions provide a consistent interface for HTTP operations across all services.

// Get is a generic helper reducing boilerplate in service GET methods.
func Get[T any](ctx context.Context, c *Client, endpoint string) (*T, error) <span class="cov7" title="3">{
        if c == nil </span><span class="cov1" title="1">{
                return nil, errors.New(ierrors.ErrClientNil)
        }</span>

        <span class="cov4" title="2">body, err := c.Do(ctx, http.MethodGet, endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var out T
        if len(body) &gt; 0 </span><span class="cov4" title="2">{
                if err := json.Unmarshal(body, &amp;out); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
                }</span>
        }

        <span class="cov1" title="1">return &amp;out, nil</span>
}

// Post is a generic helper for sending POST requests with payload.
func Post[T any](ctx context.Context, c *Client, endpoint string, payload any) (*T, error) <span class="cov7" title="3">{
        if c == nil </span><span class="cov1" title="1">{
                return nil, errors.New(ierrors.ErrClientNil)
        }</span>

        <span class="cov4" title="2">body, err := c.DoWithPayload(ctx, http.MethodPost, endpoint, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var out T
        if len(body) &gt; 0 </span><span class="cov4" title="2">{
                if err := json.Unmarshal(body, &amp;out); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
                }</span>
        }

        <span class="cov1" title="1">return &amp;out, nil</span>
}

// PostVoid is a generic helper for POST operations without expecting a response body.
func PostVoid(ctx context.Context, c *Client, endpoint string, payload any) error <span class="cov10" title="5">{
        if c == nil </span><span class="cov4" title="2">{
                return errors.New(ierrors.ErrClientNil)
        }</span>
        <span class="cov7" title="3">_, err := c.DoWithPayload(ctx, http.MethodPost, endpoint, payload)
        return err</span>
}

// PostRPCVoid is a generic helper for RPC POST operations without expecting a response body.
func PostRPCVoid(ctx context.Context, c *Client, rpcEndpoint string, payload any) error <span class="cov4" title="2">{
        if c == nil </span><span class="cov1" title="1">{
                return errors.New(ierrors.ErrClientNil)
        }</span>
        <span class="cov1" title="1">_, err := c.DoRPCWithPayload(ctx, http.MethodPost, rpcEndpoint, payload)
        return err</span>
}

// Put is a generic helper for PUT operations that expect a response body.
func Put[T any](ctx context.Context, c *Client, endpoint string, payload any) (*T, error) <span class="cov7" title="3">{
        if c == nil </span><span class="cov1" title="1">{
                return nil, errors.New(ierrors.ErrClientNil)
        }</span>

        <span class="cov4" title="2">body, err := c.DoWithPayload(ctx, http.MethodPut, endpoint, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var out T
        if len(body) &gt; 0 </span><span class="cov4" title="2">{
                if err := json.Unmarshal(body, &amp;out); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
                }</span>
        }

        <span class="cov1" title="1">return &amp;out, nil</span>
}

// PutVoid is a generic helper for PUT operations without expecting a response body.
func PutVoid(ctx context.Context, c *Client, endpoint string, payload any) error <span class="cov4" title="2">{
        if c == nil </span><span class="cov1" title="1">{
                return errors.New(ierrors.ErrClientNil)
        }</span>
        <span class="cov1" title="1">_, err := c.DoWithPayload(ctx, http.MethodPut, endpoint, payload)
        return err</span>
}

// Patch is a generic helper for PATCH operations that expect a response body.
func Patch[T any](ctx context.Context, c *Client, endpoint string, payload any) (*T, error) <span class="cov7" title="3">{
        if c == nil </span><span class="cov1" title="1">{
                return nil, errors.New(ierrors.ErrClientNil)
        }</span>

        <span class="cov4" title="2">body, err := c.DoWithPayload(ctx, http.MethodPatch, endpoint, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">var out T
        if len(body) &gt; 0 </span><span class="cov4" title="2">{
                if err := json.Unmarshal(body, &amp;out); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
                }</span>
        }

        <span class="cov1" title="1">return &amp;out, nil</span>
}

// PatchVoid is a generic helper for PATCH operations without expecting a response body.
func PatchVoid(ctx context.Context, c *Client, endpoint string, payload any) error <span class="cov4" title="2">{
        if c == nil </span><span class="cov1" title="1">{
                return errors.New(ierrors.ErrClientNil)
        }</span>
        <span class="cov1" title="1">_, err := c.DoWithPayload(ctx, http.MethodPatch, endpoint, payload)
        return err</span>
}

// Delete is a generic helper for DELETE operations without expecting a response body.
func Delete(ctx context.Context, c *Client, endpoint string) error <span class="cov4" title="2">{
        if c == nil </span><span class="cov1" title="1">{
                return errors.New(ierrors.ErrClientNil)
        }</span>
        <span class="cov1" title="1">_, err := c.Do(ctx, http.MethodDelete, endpoint)
        return err</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "fmt"
)

// RadioBand represents the radio frequency band.
type RadioBand int

// Radio configuration constants.
const (
        // RadioBand enumeration values (from iota in ap package).
        RadioBand24GHzEnum = iota
        RadioBand5GHzEnum
        RadioBand6GHzEnum

        // RadioBand24GHzValue represents the band value for 2.4 GHz radio.
        RadioBand24GHzValue = 1

        // RadioBand5GHzValue represents the band value for 5 GHz radio.
        RadioBand5GHzValue = 2

        // RadioBand6GHzValue represents the band value for 6 GHz radio.
        RadioBand6GHzValue = 3

        // RadioSlot24GHz represents the slot ID for 2.4 GHz radio.
        RadioSlot24GHz = 0

        // RadioSlot5GHz represents the slot ID for 5 GHz radio.
        RadioSlot5GHz = 1

        // RadioSlot6GHz represents the slot ID for 5 GHz radio.
        RadioSlot6GHz = 2

        // AdminStateEnabled represents the enabled admin state.
        AdminStateEnabled = "admin-state-enabled"

        // AdminStateDisabled represents the disabled admin state.
        AdminStateDisabled = "admin-state-disabled"

        // OperationEnable represents the enable operation status.
        OperationEnable = "enable"

        // OperationDisable represents the disable operation status.
        OperationDisable = "disable"
)

const (
        // RadioBand24GHz represents 2.4GHz band (slot 0).
        RadioBand24GHz RadioBand = RadioBand24GHzEnum
        // RadioBand5GHz represents 5GHz band (slot 1).
        RadioBand5GHz RadioBand = RadioBand5GHzEnum
        // RadioBand5GHz represents 5GHz band (slot 1).
        RadioBand6GHz RadioBand = RadioBand6GHzEnum
)

// RadioBandInfo represents radio band configuration information.
type RadioBandInfo struct {
        Band   uint32
        SlotID uint8
}

// GetRadioBandInfo converts RadioBand enum to band and slot-id values.
func GetRadioBandInfo(radioBand int) (RadioBandInfo, error) <span class="cov10" title="6">{
        switch radioBand </span>{
        case RadioBand24GHzEnum:<span class="cov1" title="1">
                return RadioBandInfo{
                        Band:   RadioBand24GHzValue,
                        SlotID: RadioSlot24GHz,
                }, nil</span>
        case RadioBand5GHzEnum:<span class="cov1" title="1">
                return RadioBandInfo{
                        Band:   RadioBand5GHzValue,
                        SlotID: RadioSlot5GHz,
                }, nil</span>
        case RadioBand6GHzEnum:<span class="cov1" title="1">
                return RadioBandInfo{
                        Band:   RadioBand6GHzValue,
                        SlotID: RadioSlot6GHz,
                }, nil</span>
        default:<span class="cov6" title="3">
                return RadioBandInfo{}, fmt.Errorf("radio band validation failed: %w",
                        fmt.Errorf("unsupported radio band value %v, expected %d (2.4GHz) or %d (5GHz)",
                                radioBand, RadioBand24GHzEnum, RadioBand5GHzEnum))</span>
        }
}

// GetAdminStateMode returns the admin state mode string based on enabled flag.
func GetAdminStateMode(enabled bool) string <span class="cov4" title="2">{
        if enabled </span><span class="cov1" title="1">{
                return AdminStateEnabled
        }</span>
        <span class="cov1" title="1">return AdminStateDisabled</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package errors

import "fmt"

// ServiceOperationError creates a standardized service operation error.
//
// This function provides consistent error formatting across all services
// using the pattern: "failed to {action} {serviceType} {entity}: {underlying error}"
//
// Parameters:
//   - action: The action being performed (get, set, update, etc.)
//   - serviceType: The service type (AWIPS, AFC, Client, etc.)
//   - entity: The entity or operation target
//   - err: The underlying error
//
// Returns:
//   - error: Formatted error with consistent structure
//
// Example:
//
//        err := ServiceOperationError("get", "AWIPS", "operational data", originalErr)
//        // Result: "failed to get AWIPS operational data: original error"
func ServiceOperationError(action, serviceType, entity string, err error) error <span class="cov10" title="3">{
        return fmt.Errorf("failed to %s %s %s: %w", action, serviceType, entity, err)
}</span>

// SimpleServiceError creates a simplified service error without entity specification.
//
// This function provides a simpler error format for cases where the entity
// is not specific or is part of the action description.
//
// Parameters:
//   - action: The action being performed
//   - err: The underlying error
//
// Returns:
//   - error: Formatted error with simple structure
//
// Example:
//
//        err := SimpleServiceError("retrieve configuration", originalErr)
//        // Result: "failed to retrieve configuration: original error"
func SimpleServiceError(action string, err error) error <span class="cov10" title="3">{
        return fmt.Errorf(ErrSimpleOperationFailedTemplate, action, err)
}</span>

// ValidationError creates a standardized validation error.
//
// This function provides consistent validation error formatting
// for parameter validation across all services.
//
// Parameters:
//   - parameter: The parameter name being validated
//   - value: The invalid value (as string)
//
// Returns:
//   - error: Formatted validation error
//
// Example:
//
//        err := ValidationError("MAC address", "invalid-mac")
//        // Result: "invalid MAC address: invalid-mac"
func ValidationError(parameter, value string) error <span class="cov10" title="3">{
        return fmt.Errorf(ErrInvalidParameterTemplate, parameter, value)
}</span>

// RequiredParameterError creates a standardized required parameter error.
//
// This function provides consistent error formatting for missing
// required parameters across all services.
//
// Parameters:
//   - parameter: The required parameter name
//
// Returns:
//   - error: Formatted required parameter error
//
// Example:
//
//        err := RequiredParameterError("AP MAC address")
//        // Result: "AP MAC address is required"
func RequiredParameterError(parameter string) error <span class="cov6" title="2">{
        return fmt.Errorf(ErrParameterRequiredTemplate, parameter)
}</span>

// EmptyParameterError creates a standardized empty parameter error.
//
// This function provides consistent error formatting for empty
// parameters that should not be empty.
//
// Parameters:
//   - parameter: The parameter name that is empty
//
// Returns:
//   - error: Formatted empty parameter error
//
// Example:
//
//        err := EmptyParameterError("site tag")
//        // Result: "site tag cannot be empty"
func EmptyParameterError(parameter string) error <span class="cov6" title="2">{
        return fmt.Errorf(ErrEmptyParameterTemplate, parameter)
}</span>

// NotFoundError creates a standardized entity not found error.
//
// This function provides consistent error formatting for cases
// where an entity with specific identifier is not found.
//
// Parameters:
//   - entityType: The type of entity (AP, WLAN, etc.)
//   - identifier: The identifier used to search for the entity
//
// Returns:
//   - error: Formatted not found error
//
// Example:
//
//        err := NotFoundError("AP", "28:ac:9e:11:48:10")
//        // Result: "AP with 28:ac:9e:11:48:10 not found"
func NotFoundError(entityType, identifier string) error <span class="cov6" title="2">{
        return fmt.Errorf(ErrEntityNotFoundTemplate, entityType, identifier)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package restconf

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
)

// URL construction constants.
const (
        // URLPathSeparator defines the path separator in URLs.
        URLPathSeparator = "/"
)

// Protocol constants.
const (
        // ProtocolHTTP represents HTTP protocol.
        ProtocolHTTP = "http"
        // ProtocolHTTPS represents HTTPS protocol.
        ProtocolHTTPS = "https"
        // DefaultProtocol is the default protocol for connections.
        DefaultProtocol = ProtocolHTTPS
)

// Builder provides utility functions for building WNC RESTCONF API URLs.
type Builder struct {
        protocol   string
        controller string
}

// NewBuilder creates a new RESTCONF URL builder for the specified protocol and controller.
func NewBuilder(protocol, controller string) *Builder <span class="cov8" title="9">{
        return &amp;Builder{
                protocol:   protocol,
                controller: controller,
        }
}</span>

// BuildDataURL constructs a RESTCONF data URL for the given endpoint path.
func (b *Builder) BuildDataURL(endpointPath string) string <span class="cov6" title="5">{
        if strings.HasPrefix(endpointPath, routes.RESTCONFDataPath) </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s%s", b.buildBaseURL(), endpointPath)
        }</span>
        <span class="cov6" title="4">normalizedDataPath := b.normalizeEndpointPath(endpointPath)
        return fmt.Sprintf("%s%s%s", b.buildBaseURL(), routes.RESTCONFDataPath, normalizedDataPath)</span>
}

// BuildOperationsURL constructs a RESTCONF operations URL for the given RPC path.
func (b *Builder) BuildOperationsURL(rpcPath string) string <span class="cov6" title="4">{
        if strings.HasPrefix(rpcPath, routes.RESTCONFOperationsPath) </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s%s", b.buildBaseURL(), rpcPath)
        }</span>
        <span class="cov4" title="3">normalizedOperationsPath := b.normalizeEndpointPath(rpcPath)
        return fmt.Sprintf("%s%s%s", b.buildBaseURL(), routes.RESTCONFOperationsPath, normalizedOperationsPath)</span>
}

// BuildQueryURL constructs URLs for queries with key-value parameters
// Format: endpoint=identifier.
func (b *Builder) BuildQueryURL(endpoint, identifier string) string <span class="cov4" title="3">{
        return fmt.Sprintf("%s=%s", endpoint, identifier)
}</span>

// BuildQueryCompositeURL constructs URLs for queries with composite parameters
// Format: endpoint=value1,value2,value3...
func (b *Builder) BuildQueryCompositeURL(endpoint string, values ...interface{}) string <span class="cov8" title="8">{
        strValues := make([]string, len(values))
        for i, v := range values </span><span class="cov9" title="11">{
                switch val := v.(type) </span>{
                case string:<span class="cov6" title="4">
                        strValues[i] = val</span>
                case int:<span class="cov1" title="1">
                        strValues[i] = strconv.Itoa(val)</span>
                case int64:<span class="cov1" title="1">
                        strValues[i] = strconv.FormatInt(val, 10)</span>
                case float64:<span class="cov1" title="1">
                        strValues[i] = strconv.FormatFloat(val, 'f', -1, 64)</span>
                case bool:<span class="cov4" title="3">
                        strValues[i] = strconv.FormatBool(val)</span>
                default:<span class="cov1" title="1">
                        strValues[i] = fmt.Sprintf("%v", val)</span>
                }
        }
        <span class="cov8" title="8">return fmt.Sprintf("%s=%s", endpoint, strings.Join(strValues, ","))</span>
}

// buildBaseURL constructs the base URL for the controller.
func (b *Builder) buildBaseURL() string <span class="cov10" title="12">{
        return fmt.Sprintf("%s://%s", b.protocol, b.controller)
}</span>

// normalizeEndpointPath ensures endpoint path starts with forward slash.
func (b *Builder) normalizeEndpointPath(endpointPath string) string <span class="cov10" title="12">{
        if !strings.HasPrefix(endpointPath, URLPathSeparator) </span><span class="cov8" title="7">{
                return URLPathSeparator + endpointPath
        }</span>
        <span class="cov6" title="5">return endpointPath</span>
}

// isValidProtocol checks if the protocol is supported.
func isValidProtocol(protocol string) bool <span class="cov8" title="7">{
        return protocol == ProtocolHTTP || protocol == ProtocolHTTPS
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package service provides common service infrastructure for Cisco IOS-XE Wireless Network Controller API services.
package service

import (
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
)

// BaseService provides common service infrastructure that all domain services can embed.
//
// This structure standardizes service creation patterns and provides consistent
// error handling and validation across all service implementations.
type BaseService struct {
        // client provides the underlying HTTP client for RESTCONF API communication
        client *core.Client
}

// NewBaseService creates a new base service instance with the provided client.
//
// This constructor provides standardized validation and setup for all services
// that embed BaseService, ensuring consistent initialization patterns.
//
// Parameters:
//   - client: Configured core.Client for RESTCONF API communication
//
// Returns:
//   - BaseService: New base service instance ready for use by embedding services
func NewBaseService(client *core.Client) BaseService <span class="cov10" title="6">{
        return BaseService{client: client}
}</span>

// Client returns the underlying HTTP client for advanced use cases.
//
// This method provides access to the configured client instance for services
// that need direct client access or custom operations beyond the standard patterns.
//
// Note: This method will return nil if the BaseService was not properly initialized
// with a valid client. Services should handle nil return values appropriately.
//
// Returns:
//   - *core.Client: The configured HTTP client instance, or nil if not initialized
func (b BaseService) Client() *core.Client <span class="cov7" title="4">{
        return b.client
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package testutil provides internal test helpers and utilities for unit testing.
package testutil

import (
        "reflect"
        "strings"
        "testing"
        "time"
)

// AssertBoolEquals validates that the actual boolean value matches the expected boolean value.
func AssertBoolEquals(t *testing.T, actual, expected bool, message string) <span class="cov10" title="2">{
        t.Helper()

        if actual != expected </span><span class="cov0" title="0">{
                t.Errorf("%s: Expected %t, got %t", message, expected, actual)
        }</span>
}

// AssertTrue validates that a boolean value is true.
func AssertTrue(t *testing.T, actual bool, context string) <span class="cov1" title="1">{
        t.Helper()

        if !actual </span><span class="cov0" title="0">{
                t.Errorf("%s: Expected true, got false", context)
        }</span>
}

// AssertFalse validates that a boolean value is false.
func AssertFalse(t *testing.T, actual bool, context string) <span class="cov1" title="1">{
        t.Helper()

        if actual </span><span class="cov0" title="0">{
                t.Errorf("%s: Expected false, got true", context)
        }</span>
}

// AssertPointerNil validates that a pointer is nil.
func AssertPointerNil(t *testing.T, actual any, context string) <span class="cov10" title="2">{
        t.Helper()

        if actual == nil </span><span class="cov1" title="1">{
                return // Success - pointer is nil
        }</span>

        // Use reflection to check if the pointer value is nil
        <span class="cov1" title="1">rv := reflect.ValueOf(actual)
        if rv.Kind() == reflect.Pointer &amp;&amp; rv.IsNil() </span><span class="cov1" title="1">{
                return // Success - pointer value is nil
        }</span>

        <span class="cov0" title="0">t.Errorf("%s: Expected pointer to be nil, got %v", context, actual)</span>
}

// AssertClientCreated validates that a client was successfully created.
func AssertClientCreated(t *testing.T, client any, err error, context string) <span class="cov1" title="1">{
        t.Helper()

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected successful client creation, got error: %v", context, err)
        }</span>
        <span class="cov1" title="1">if client == nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected non-nil client", context)
        }</span>
}

// AssertClientCreationError validates that client creation failed with an error.
func AssertClientCreationError(t *testing.T, err error, context string) <span class="cov1" title="1">{
        t.Helper()

        if err == nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected error but got none", context)
        }</span>
}

// AssertError validates that an error occurred.
func AssertError(t *testing.T, err error, context string) <span class="cov1" title="1">{
        t.Helper()

        if err == nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected error but got none", context)
        }</span>
}

// AssertNoError validates that no error occurred.
func AssertNoError(t *testing.T, err error, context string) <span class="cov1" title="1">{
        t.Helper()

        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected no error, got: %v", context, err)
        }</span>
}

// AssertErrorContains validates that an error occurred and contains specific text.
func AssertErrorContains(t *testing.T, err error, expectedText, context string) <span class="cov1" title="1">{
        t.Helper()

        if err == nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected error but got none", context)
        }</span>
        <span class="cov1" title="1">if !strings.Contains(err.Error(), expectedText) </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected error containing '%s', got: %v", context, expectedText, err)
        }</span>
}

// AssertNotNil validates that a value is not nil.
func AssertNotNil(t *testing.T, value any, context string) <span class="cov1" title="1">{
        t.Helper()

        if value == nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected non-nil value", context)
        }</span>
}

// AssertNil validates that a value is nil.
func AssertNil(t *testing.T, value any, context string) <span class="cov1" title="1">{
        t.Helper()

        if value != nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected nil value, got: %v", context, value)
        }</span>
}

// AssertStringEquals validates that two strings are equal.
func AssertStringEquals(t *testing.T, actual, expected, context string) <span class="cov1" title="1">{
        t.Helper()

        if actual != expected </span><span class="cov0" title="0">{
                t.Errorf("%s: Expected '%s', got '%s'", context, expected, actual)
        }</span>
}

// AssertStringNotEmpty validates that a string is not empty.
func AssertStringNotEmpty(t *testing.T, value, context string) <span class="cov1" title="1">{
        t.Helper()

        if value == "" </span><span class="cov0" title="0">{
                t.Error(context + ": Expected non-empty string")
        }</span>
}

// AssertErrorMessage validates that an error has the expected message.
func AssertErrorMessage(t *testing.T, err error, expected, context string) <span class="cov1" title="1">{
        t.Helper()

        if err == nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: Expected error but got none", context)
        }</span>
        <span class="cov1" title="1">if err.Error() != expected </span><span class="cov0" title="0">{
                t.Errorf("%s: Expected error message '%s', got '%s'", context, expected, err.Error())
        }</span>
}

// AssertIntEquals validates that two integer values are equal.
func AssertIntEquals(t *testing.T, actual, expected int, context string) <span class="cov1" title="1">{
        t.Helper()

        if actual != expected </span><span class="cov0" title="0">{
                t.Errorf("%s: Expected count %d, got %d", context, expected, actual)
        }</span>
}

// AssertStringContains validates that a string contains specific text.
func AssertStringContains(t *testing.T, text, expectedSubstring, context string) <span class="cov0" title="0">{
        t.Helper()

        if !strings.Contains(text, expectedSubstring) </span><span class="cov0" title="0">{
                t.Errorf("%s: Expected text to contain '%s', got '%s'", context, expectedSubstring, text)
        }</span>
}

// AssertDurationEquals validates that two time.Duration values are equal.
func AssertDurationEquals(t *testing.T, actual, expected time.Duration, context string) <span class="cov1" title="1">{
        t.Helper()

        if actual != expected </span><span class="cov0" title="0">{
                t.Errorf("%s: Expected duration %v, got %v", context, expected, actual)
        }</span>
}

// AssertPointerEquals validates that two pointers are equal.
func AssertPointerEquals(t *testing.T, actual, expected any, context string) <span class="cov0" title="0">{
        t.Helper()

        if actual != expected </span><span class="cov0" title="0">{
                t.Errorf("%s: Expected pointer %v, got %v", context, expected, actual)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package transport provides HTTP client utilities and request creation functions.
package transport

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net/http"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf"
)

// RequestBuilder provides HTTP request creation utilities.
type RequestBuilder struct {
        restBuilder *restconf.Builder
        token       string
        logger      *slog.Logger
}

// NewRequestBuilder creates a new RequestBuilder instance.
func NewRequestBuilder(restBuilder *restconf.Builder, token string, logger *slog.Logger) *RequestBuilder <span class="cov10" title="17">{
        return &amp;RequestBuilder{
                restBuilder: restBuilder,
                token:       token,
                logger:      logger,
        }
}</span>

// CreateRequest creates and configures an HTTP request.
func (rb *RequestBuilder) CreateRequest(ctx context.Context, method, path string) (*http.Request, error) <span class="cov6" title="6">{
        if rb.restBuilder == nil </span><span class="cov1" title="1">{
                return nil, errors.New("RESTCONF builder is not properly initialized")
        }</span>

        <span class="cov6" title="5">url := rb.restBuilder.BuildDataURL(path)

        req, err := http.NewRequestWithContext(ctx, method, url, http.NoBody)
        if err != nil </span><span class="cov1" title="1">{
                rb.logger.Error("Failed to create HTTP request", "error", err, "url", url)
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov5" title="4">req.Header = DefaultHeaders(rb.token)
        rb.logger.Debug("Sending API request", "method", method, "url", url)
        return req, nil</span>
}

// CreateRequestWithPayload creates and configures an HTTP request with a JSON payload.
func (rb *RequestBuilder) CreateRequestWithPayload(
        ctx context.Context,
        method, path string,
        payload any,
) (*http.Request, error) <span class="cov5" title="4">{
        if rb.restBuilder == nil </span><span class="cov1" title="1">{
                return nil, errors.New("RESTCONF builder is not properly initialized")
        }</span>

        // Handle nil payload case early - reuse CreateRequest logic
        <span class="cov4" title="3">if payload == nil </span><span class="cov1" title="1">{
                return rb.CreateRequest(ctx, method, path)
        }</span>

        <span class="cov3" title="2">url := rb.restBuilder.BuildDataURL(path)

        // Marshal payload and create request
        return rb.createRequestWithJSONPayload(ctx, method, url, payload, "")</span>
}

// CreateRPCRequestWithPayload creates and configures an HTTP RPC request with a JSON payload.
func (rb *RequestBuilder) CreateRPCRequestWithPayload(
        ctx context.Context,
        method, rpcPath string,
        payload any,
) (*http.Request, error) <span class="cov6" title="5">{
        if rb.restBuilder == nil </span><span class="cov1" title="1">{
                return nil, errors.New("RESTCONF builder is not properly initialized")
        }</span>

        // Handle nil payload case early
        <span class="cov5" title="4">if payload == nil </span><span class="cov3" title="2">{
                url := rb.restBuilder.BuildOperationsURL(rpcPath)
                req, err := http.NewRequestWithContext(ctx, method, url, http.NoBody)
                if err != nil </span><span class="cov1" title="1">{
                        rb.logger.Error("Failed to create HTTP RPC request", "error", err, "url", url)
                        return nil, fmt.Errorf("failed to create RPC request: %w", err)
                }</span>
                <span class="cov1" title="1">req.Header = DefaultHeaders(rb.token)
                rb.logger.Debug("Sending RPC request", "method", method, "url", url)
                return req, nil</span>
        }

        <span class="cov3" title="2">url := rb.restBuilder.BuildOperationsURL(rpcPath)
        // Marshal payload and create RPC request
        return rb.createRequestWithJSONPayload(ctx, method, url, payload, "RPC")</span>
}

// ExecuteRequest executes an HTTP request and handles basic error conditions.
func (rb *RequestBuilder) ExecuteRequest(httpClient *http.Client, req *http.Request) (*http.Response, error) <span class="cov4" title="3">{
        if req == nil </span><span class="cov1" title="1">{
                return nil, errors.New("request cannot be nil")
        }</span>
        <span class="cov3" title="2">resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                rb.logger.Error("HTTP request failed", "error", err, "url", req.URL.String())
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov3" title="2">return resp, nil</span>
}

// createRequestWithJSONPayload creates an HTTP request with JSON payload and proper headers.
func (rb *RequestBuilder) createRequestWithJSONPayload(
        ctx context.Context,
        method, url string,
        payload any,
        logType string,
) (*http.Request, error) <span class="cov5" title="4">{
        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to marshal payload: %w", err)
        }</span>

        <span class="cov3" title="2">body := bytes.NewReader(jsonData)
        req, err := http.NewRequestWithContext(ctx, method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                rb.logger.Error("Failed to create HTTP "+logType+" request", "error", err, "url", url)
                return nil, fmt.Errorf("failed to create "+logType+" request: %w", err)
        }</span>

        <span class="cov3" title="2">req.Header = DefaultHeaders(rb.token)
        req.Header.Set("Content-Type", HTTPHeaderValueYANGData)
        rb.logger.Debug("Sending "+logType+" request", "method", method, "url", url)
        return req, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package transport provides HTTP transport and header utilities for the WNC client.
package transport

import (
        "crypto/tls"
        "net/http"
        "time"
)

// HTTP header key constants.
const (
        // HTTPHeaderKeyAuthorization defines the Authorization header key.
        HTTPHeaderKeyAuthorization = "Authorization"
        // HTTPHeaderKeyAccept defines the Accept header key.
        HTTPHeaderKeyAccept = "Accept"
        // HTTPHeaderKeyUserAgent defines the User-Agent header key.
        HTTPHeaderKeyUserAgent = "User-Agent"
        // HTTPHeaderKeyContentType defines the Content-Type header key.
        HTTPHeaderKeyContentType = "Content-Type"
)

// HTTP header value constants.
const (
        // HTTPHeaderValueBasicPrefix defines the Basic authentication prefix.
        HTTPHeaderValueBasicPrefix = "Basic "
        // HTTPHeaderValueYANGData defines the YANG data content type.
        HTTPHeaderValueYANGData = "application/yang-data+json"
        // HTTPHeaderUserAgent defines the User-Agent string.
        HTTPHeaderUserAgent = "wnc-go-client/1.0"
        // HTTPHeaderAccept defines the default Accept header value.
        HTTPHeaderAccept = HTTPHeaderValueYANGData
        // HTTPHeaderContentType defines the default Content-Type header value.
        HTTPHeaderContentType = HTTPHeaderValueYANGData
)

// HTTP connection pool constants.
const (
        // DefaultMaxIdleConns is the maximum number of idle connections across all hosts.
        DefaultMaxIdleConns = 100
        // DefaultMaxIdleConnsPerHost is the maximum number of idle connections per host.
        DefaultMaxIdleConnsPerHost = 10
        // DefaultTLSHandshakeTimeout is the default timeout for TLS handshake.
        DefaultTLSHandshakeTimeout = QuickTimeout
        // DefaultResponseHeaderTimeout is the default timeout for response headers.
        DefaultResponseHeaderTimeout = QuickTimeout
        // DefaultIdleConnTimeout is the default timeout for idle connections.
        DefaultIdleConnTimeout = ExtendedTimeout
        // ExtendedTimeout for longer operations (idle connections).
        ExtendedTimeout = 90 * time.Second
        // QuickTimeout for fast operations (TLS handshake, response headers).
        QuickTimeout = 5 * time.Second
)

// NewTransport creates and configures a new HTTP transport with the specified TLS settings.
func NewTransport(skipVerify bool) *http.Transport <span class="cov5" title="3">{
        return &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: skipVerify, //nolint:gosec
                },
                ForceAttemptHTTP2:     false,
                DisableKeepAlives:     false,
                DisableCompression:    false,
                TLSHandshakeTimeout:   DefaultTLSHandshakeTimeout,
                ResponseHeaderTimeout: DefaultResponseHeaderTimeout,
                IdleConnTimeout:       DefaultIdleConnTimeout,
                MaxIdleConns:          DefaultMaxIdleConns,
                MaxIdleConnsPerHost:   DefaultMaxIdleConnsPerHost,
        }
}</span>

// DefaultHeaders returns a pre-configured header map with authentication and content type.
func DefaultHeaders(token string) http.Header <span class="cov10" title="9">{
        headers := make(http.Header)
        headers.Set(HTTPHeaderKeyAuthorization, HTTPHeaderValueBasicPrefix+token)
        headers.Set(HTTPHeaderKeyAccept, HTTPHeaderValueYANGData)
        headers.Set(HTTPHeaderKeyUserAgent, HTTPHeaderUserAgent)
        return headers
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package validation

import (
        "fmt"
        "strings"
        "time"
)

const (
        // MACAddressHexCharLength is the required length for MAC address hex characters.
        MACAddressHexCharLength = 12
)

// Default tag values for AP operations.
const (
        // DefaultSiteTag represents the default site tag value.
        DefaultSiteTag = "default-site-tag"

        // DefaultPolicyTag represents the default policy tag value.
        DefaultPolicyTag = "default-policy-tag"

        // DefaultRFTag represents the default RF tag value.
        DefaultRFTag = "default-rf-tag"
)

// Validation constants.
const (
        // MinEndpointLength is the minimum length for API endpoints.
        MinEndpointLength = 10

        // MinTokenLength is the minimum length for authentication tokens.
        MinTokenLength = 8

        // ValidationTimeoutThreshold is the minimum timeout for validation.
        ValidationTimeoutThreshold = 1
)

// Error message templates for validation errors.
const (
        // EndpointMismatchErrorTemplate is used for endpoint validation errors.
        EndpointMismatchErrorTemplate = "Expected %s = %s, got %s"

        // EmptyEndpointErrorTemplate is used when an endpoint is empty.
        EmptyEndpointErrorTemplate = "%s endpoint is empty"

        // ShortEndpointErrorTemplate is used when an endpoint is too short.
        ShortEndpointErrorTemplate = "%s endpoint is too short: %s"

        // InvalidEndpointErrorTemplate is used for invalid endpoint formats.
        InvalidEndpointErrorTemplate = "%s endpoint has invalid format: %s"
)

// Core validation functions

// IsValidController checks if controller address is valid (non-empty).
func IsValidController(controller string) bool <span class="cov4" title="6">{
        return IsNonEmptyString(controller)
}</span>

// IsValidAccessToken checks if access token is valid (non-empty).
func IsValidAccessToken(accessToken string) bool <span class="cov4" title="5">{
        return IsNonEmptyString(accessToken)
}</span>

// IsPositiveTimeout checks if timeout is greater than validation threshold.
func IsPositiveTimeout(timeout time.Duration) bool <span class="cov3" title="4">{
        return timeout &gt; ValidationTimeoutThreshold*time.Second
}</span>

// IsValidTimeout returns true if timeout is greater than zero.
func IsValidTimeout(timeout time.Duration) bool <span class="cov3" title="3">{
        return timeout &gt; 0
}</span>

// ValidateNonEmptyString validates that a string is not empty after trimming whitespace.
func ValidateNonEmptyString(s, fieldName string) error <span class="cov3" title="4">{
        if !IsNonEmptyString(s) </span><span class="cov2" title="2">{
                return fmt.Errorf("validation failed: %w",
                        fmt.Errorf("field %s cannot be empty or contain only whitespace", fieldName))
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// String validation predicates

// IsNonEmptyString checks if a string is not empty after trimming whitespace.
func IsNonEmptyString(s string) bool <span class="cov8" title="39">{
        return strings.TrimSpace(s) != ""
}</span>

// IsStringEmpty returns true if the string is literally empty (not trimmed)
// This is different from !IsNonEmptyString as it doesn't trim whitespace.
func IsStringEmpty(str string) bool <span class="cov4" title="7">{
        return str == ""
}</span>

// MAC address validation functions

// ValidateMACAddress validates MAC address format.
// MAC address can be formatted as aa:bb:cc:dd:ee:ff, aa-bb-cc-dd-ee-ff, or aabbccddeeff.
func ValidateMACAddress(mac string) error <span class="cov5" title="11">{
        normalized := normalizeMACAddress(mac)

        if len(normalized) != MACAddressHexCharLength </span><span class="cov3" title="4">{
                return fmt.Errorf("MAC address must be %d hex characters, got %d", MACAddressHexCharLength, len(normalized))
        }</span>

        <span class="cov4" title="7">for _, c := range normalized </span><span class="cov10" title="84">{
                if (c &lt; '0' || c &gt; '9') &amp;&amp; (c &lt; 'a' || c &gt; 'f') &amp;&amp; (c &lt; 'A' || c &gt; 'F') </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid hexadecimal character '%c' in MAC address %s", c, mac)
                }</span>
        }

        <span class="cov4" title="7">return nil</span>
}

// NormalizeMACAddress validates and normalizes MAC address to colon-separated format (aa:bb:cc:dd:ee:ff).
// Returns normalized MAC address and validation error if invalid.
func NormalizeMACAddress(mac string) (string, error) <span class="cov3" title="3">{
        if err := ValidateMACAddress(mac); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov3" title="3">normalized := strings.ToLower(normalizeMACAddress(mac))
        var result strings.Builder
        for i := 0; i &lt; len(normalized); i += 2 </span><span class="cov6" title="18">{
                if i &gt; 0 </span><span class="cov6" title="15">{
                        result.WriteString(":")
                }</span>
                <span class="cov6" title="18">result.WriteString(normalized[i : i+2])</span>
        }

        <span class="cov3" title="3">return result.String(), nil</span>
}

// normalizeMACAddress removes all separators from MAC address.
func normalizeMACAddress(mac string) string <span class="cov6" title="14">{
        normalized := strings.ReplaceAll(mac, ":", "")
        normalized = strings.ReplaceAll(normalized, "-", "")
        normalized = strings.ReplaceAll(normalized, ".", "")
        return normalized
}</span>

// IsValidMACAddr performs MAC address validation and returns boolean.
func IsValidMACAddr(mac string) bool <span class="cov4" title="5">{
        return ValidateMACAddress(mac) == nil
}</span>

// ValidateSlotID validates slot ID (radio slot, antenna slot, etc.)
func ValidateSlotID(slotID int) error <span class="cov2" title="2">{
        if slotID &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("slot ID must be non-negative, got %d", slotID)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// ValidateSpatialStream validates the spatial stream parameter (must be 1-8).
func ValidateSpatialStream(spatialStream int) error <span class="cov2" title="2">{
        if spatialStream &lt; 1 || spatialStream &gt; 8 </span><span class="cov1" title="1">{
                return fmt.Errorf("spatial stream must be between 1 and 8, got %d", spatialStream)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// ValidateWlanID validates WLAN ID format.
func ValidateWlanID(wlanID string) error <span class="cov2" title="2">{
        return ValidateNonEmptyString(wlanID, "WLAN ID")
}</span>

// HasValidTags checks if at least one tag is provided.
func HasValidTags(siteTag, policyTag, rfTag string) bool <span class="cov3" title="3">{
        return IsNonEmptyString(siteTag) || IsNonEmptyString(policyTag) || IsNonEmptyString(rfTag)
}</span>

// HasValidMACOrName checks if either MAC address or AP name is provided (but not both).
func HasValidMACOrName(apMAC, apName string) bool <span class="cov3" title="4">{
        return (IsNonEmptyString(apMAC) &amp;&amp; IsStringEmpty(apName)) ||
                (IsStringEmpty(apMAC) &amp;&amp; IsNonEmptyString(apName))
}</span>

// HasEitherMACOrName checks if at least one of MAC address or AP name is provided.
func HasEitherMACOrName(apMAC, apName string) bool <span class="cov2" title="2">{
        return IsNonEmptyString(apMAC) || IsNonEmptyString(apName)
}</span>

// General utility predicates

// SelectNonEmptyValue returns the primary value if not empty, otherwise returns the default value.
func SelectNonEmptyValue(primary, defaultValue string) string <span class="cov2" title="2">{
        if IsNonEmptyString(primary) </span><span class="cov1" title="1">{
                return primary
        }</span>
        <span class="cov1" title="1">return defaultValue</span>
}

// IsValidTagAssignment validates tag value based on tag type.
func IsValidTagAssignment(tagValue, tagType string) bool <span class="cov4" title="5">{
        switch tagType </span>{
        case "site":<span class="cov2" title="2">
                return IsNonEmptyString(tagValue)</span>
        case "policy":<span class="cov1" title="1">
                return IsNonEmptyString(tagValue)</span>
        case "rf":<span class="cov1" title="1">
                return IsNonEmptyString(tagValue)</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package testutil

import (
        "context"
        "testing"
        "time"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/transport"
)

// TestContext creates a test context with appropriate timeout.
func TestContext(t *testing.T) context.Context <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), transport.QuickTimeout)
        t.Cleanup(cancel)
        return ctx
}</span>

// TestContextWithTimeout creates a test context with custom timeout.
func TestContextWithTimeout(t *testing.T, timeout time.Duration) context.Context <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        t.Cleanup(cancel)
        return ctx
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package testutil

import (
        "net/http"
        "net/http/httptest"
        "strings"
        "testing"
)

// HandlerMap represents the handler mapping structure for mock servers.
type HandlerMap[T any] = map[string]map[string]T

// RESTCONFServer provides a flexible mock RESTCONF server for testing.
type RESTCONFServer struct {
        *httptest.Server
        handlers HandlerMap[func() (int, string)] // method -&gt; path -&gt; handler
}

// NewRESTCONFSuccessServer creates an HTTPS test server that returns 200 OK with the provided
// JSON body for each RESTCONF endpoint given. Keys in the map are endpoint strings without the
// RESTCONF prefix (e.g., "Cisco-...:container/sub" or "operations/Cisco-...:rpc"). Values are raw JSON payloads to return.
// Any non-matching path returns 404.
func NewRESTCONFSuccessServer(endpoints map[string]string) *httptest.Server <span class="cov9" title="7">{
        handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov5" title="3">{
                ep := r.URL.Path
                ep = strings.TrimPrefix(ep, "/restconf/data/")
                ep = strings.TrimPrefix(ep, "/restconf/operations/")

                if body, ok := endpoints[ep]; ok </span><span class="cov4" title="2">{
                        w.WriteHeader(http.StatusOK)
                        _, _ = w.Write([]byte(body))
                        return
                }</span>
                <span class="cov1" title="1">http.NotFound(w, r)</span>
        })
        <span class="cov9" title="7">return httptest.NewTLSServer(handler)</span>
}

// NewRESTCONFErrorServer creates an HTTPS test server that returns the provided status code
// for all listed RESTCONF endpoints. Endpoints should be provided without the RESTCONF prefix.
// Supports both data operations and RPC operations paths.
// Non-listed paths return 404.
func NewRESTCONFErrorServer(paths []string, status int) *httptest.Server <span class="cov5" title="3">{ //nolint:revive // test helper
        handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov1" title="1">{
                // Handle both data operations (/restconf/data/) and RPC operations (/restconf/operations/)
                ep := r.URL.Path
                ep = strings.TrimPrefix(ep, "/restconf/data/")
                ep = strings.TrimPrefix(ep, "/restconf/operations/")

                for _, p := range paths </span><span class="cov1" title="1">{
                        if ep == p </span><span class="cov1" title="1">{
                                http.Error(w, http.StatusText(status), status)
                                return
                        }</span>
                }
                <span class="cov0" title="0">http.NotFound(w, r)</span>
        })
        <span class="cov5" title="3">return httptest.NewTLSServer(handler)</span>
}

// NewRESTCONFServer creates a new flexible RESTCONF server for testing.
func NewRESTCONFServer(t *testing.T) *RESTCONFServer <span class="cov10" title="8">{
        t.Helper()
        server := &amp;RESTCONFServer{
                handlers: nil,
        }

        // Helper functions for cleaner handler logic
        normalizePath := func(path string) string </span><span class="cov5" title="3">{
                path = strings.TrimPrefix(path, "/restconf/data/")
                path = strings.TrimPrefix(path, "/restconf/operations/")
                return path
        }</span>

        <span class="cov10" title="8">findHandler := func(path string, methodHandlers map[string]func() (int, string)) func() (int, string) </span><span class="cov1" title="1">{
                for pathPrefix, handler := range methodHandlers </span><span class="cov1" title="1">{
                        if strings.Contains(path, pathPrefix) </span><span class="cov1" title="1">{
                                return handler
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov10" title="8">writeResponse := func(w http.ResponseWriter, status int, body string) </span><span class="cov1" title="1">{
                w.WriteHeader(status)
                if body != "" </span><span class="cov1" title="1">{
                        _, _ = w.Write([]byte(body))
                }</span>
        }

        <span class="cov10" title="8">handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov5" title="3">{
                path := normalizePath(r.URL.Path)
                methodHandlers, ok := server.handlers[r.Method]
                if !ok </span><span class="cov4" title="2">{
                        http.NotFound(w, r)
                        return
                }</span>

                <span class="cov1" title="1">if handler := findHandler(path, methodHandlers); handler != nil </span><span class="cov1" title="1">{
                        status, body := handler()
                        writeResponse(w, status, body)
                        return
                }</span>

                <span class="cov0" title="0">http.NotFound(w, r)</span>
        })

        <span class="cov10" title="8">server.Server = httptest.NewTLSServer(handler)
        return server</span>
}

// AddHandler adds a handler for a specific HTTP method and path pattern.
func (s *RESTCONFServer) AddHandler(method, pathPrefix string, handler func() (int, string)) <span class="cov9" title="7">{
        if s.handlers == nil </span><span class="cov7" title="5">{
                s.handlers = make(HandlerMap[func() (int, string)])
        }</span>
        <span class="cov9" title="7">if s.handlers[method] == nil </span><span class="cov8" title="6">{
                s.handlers[method] = make(map[string]func() (int, string))
        }</span>
        <span class="cov9" title="7">s.handlers[method][pathPrefix] = handler</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package testutil

import (
        "net/http/httptest"
        "net/url"
        "testing"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
)

// TestClient represents a test client with core functionality hidden.
type TestClient interface {
        // Core returns the underlying core client for service initialization.
        // The concrete type is *core.Client but returned as interface{} to hide internals.
        Core() interface{}
}

// MockServer represents a mock RESTCONF server for testing.
type MockServer interface {
        URL() string
        Close()
}

// ResponseConfig defines configuration for custom responses.
type ResponseConfig struct {
        StatusCode int
        Body       string
        Method     string // HTTP method, defaults to "GET" if empty
}

// MockServerOption configures a MockServer.
type MockServerOption func(*mockServerConfig)

// mockServerConfig holds configuration for MockServer.
type mockServerConfig struct {
        testing         *testing.T
        successPaths    map[string]string         // path -&gt; response body (200 OK)
        errorPaths      map[string]int            // path -&gt; status code
        customResponses map[string]ResponseConfig // path -&gt; full response config
}

// testClientImpl implements TestClient interface hiding internal details.
type testClientImpl struct {
        client *core.Client
}

// Core returns the core client as interface{} to hide the concrete type.
func (tc *testClientImpl) Core() interface{} <span class="cov3" title="2">{
        return tc.client
}</span>

// mockServerImpl implements MockServer interface wrapping httptest.Server.
type mockServerImpl struct {
        server *httptest.Server
}

// URL returns the mock server URL.
func (ms *mockServerImpl) URL() string <span class="cov7" title="8">{
        return ms.server.URL
}</span>

// Close shuts down the mock server.
func (ms *mockServerImpl) Close() <span class="cov8" title="11">{
        ms.server.Close()
}</span>

// WithSuccessResponse adds a successful response for a specific path.
func WithSuccessResponse(path, body string) MockServerOption <span class="cov3" title="2">{
        return func(cfg *mockServerConfig) </span><span class="cov3" title="2">{
                if cfg.successPaths == nil </span><span class="cov3" title="2">{
                        cfg.successPaths = make(map[string]string)
                }</span>
                <span class="cov3" title="2">cfg.successPaths[path] = body</span>
        }
}

// WithSuccessResponses adds multiple successful responses.
func WithSuccessResponses(responses map[string]string) MockServerOption <span class="cov6" title="5">{
        return func(cfg *mockServerConfig) </span><span class="cov6" title="5">{
                if cfg.successPaths == nil </span><span class="cov6" title="5">{
                        cfg.successPaths = make(map[string]string)
                }</span>
                <span class="cov6" title="5">for path, body := range responses </span><span class="cov6" title="5">{
                        cfg.successPaths[path] = body
                }</span>
        }
}

// WithErrorResponse adds an error response for a specific path.
func WithErrorResponse(path string, statusCode int) MockServerOption <span class="cov1" title="1">{
        return func(cfg *mockServerConfig) </span><span class="cov1" title="1">{
                if cfg.errorPaths == nil </span><span class="cov1" title="1">{
                        cfg.errorPaths = make(map[string]int)
                }</span>
                <span class="cov1" title="1">cfg.errorPaths[path] = statusCode</span>
        }
}

// WithErrorResponses adds error responses for multiple paths.
func WithErrorResponses(paths []string, statusCode int) MockServerOption <span class="cov3" title="2">{
        return func(cfg *mockServerConfig) </span><span class="cov3" title="2">{
                if cfg.errorPaths == nil </span><span class="cov3" title="2">{
                        cfg.errorPaths = make(map[string]int)
                }</span>
                <span class="cov3" title="2">for _, path := range paths </span><span class="cov3" title="2">{
                        cfg.errorPaths[path] = statusCode
                }</span>
        }
}

// WithCustomResponse adds a fully customizable response.
func WithCustomResponse(path string, config ResponseConfig) MockServerOption <span class="cov4" title="3">{
        return func(cfg *mockServerConfig) </span><span class="cov4" title="3">{
                if cfg.customResponses == nil </span><span class="cov4" title="3">{
                        cfg.customResponses = make(map[string]ResponseConfig)
                }</span>
                <span class="cov4" title="3">cfg.customResponses[path] = config</span>
        }
}

// WithTesting provides a testing.T instance for enhanced server capabilities.
func WithTesting(t *testing.T) MockServerOption <span class="cov4" title="3">{
        return func(cfg *mockServerConfig) </span><span class="cov4" title="3">{
                cfg.testing = t
        }</span>
}

// NewTestClient creates a test client for the given mock server.
func NewTestClient(server MockServer) TestClient <span class="cov4" title="3">{
        // Create a minimal test client without requiring *testing.T
        serverImpl, ok := server.(*mockServerImpl)
        if !ok </span><span class="cov0" title="0">{
                panic("testutil: server must be created with NewMockServer()")</span>
        }

        // Parse the server URL to get the host
        <span class="cov4" title="3">u, err := url.Parse(serverImpl.server.URL)
        if err != nil </span><span class="cov0" title="0">{
                panic("testutil: failed to parse server URL: " + err.Error())</span>
        }

        // Create core client using the mock server host
        <span class="cov4" title="3">client, err := core.New(u.Host, "test-token", core.WithInsecureSkipVerify(true))
        if err != nil </span><span class="cov0" title="0">{
                panic("testutil: failed to create test client: " + err.Error())</span>
        }

        <span class="cov4" title="3">return &amp;testClientImpl{client: client}</span>
}

// NewMockServer creates a mock RESTCONF server with functional options.
// This is the unified constructor that supports all testing scenarios.
//
// Examples:
//
//        // Simple success responses
//        server := NewMockServer(WithSuccessResponses(map[string]string{"path": "response"}))
//
//        // Error responses
//        server := NewMockServer(WithErrorResponses([]string{"path"}, 404))
//
//        // Mixed responses
//        server := NewMockServer(
//          WithSuccessResponse("success-path", `{"status":"ok"}`),
//          WithErrorResponse("error-path", 500),
//          WithTesting(t),
//        )
func NewMockServer(opts ...MockServerOption) MockServer <span class="cov8" title="11">{
        cfg := &amp;mockServerConfig{}
        for _, opt := range opts </span><span class="cov10" title="16">{
                opt(cfg)
        }</span>

        // If we have custom responses or testing context, use the flexible server
        <span class="cov8" title="11">if len(cfg.customResponses) &gt; 0 || cfg.testing != nil </span><span class="cov5" title="4">{
                return newAdvancedMockServer(cfg)
        }</span>

        // Handle simple success-only case
        <span class="cov7" title="7">if len(cfg.successPaths) &gt; 0 &amp;&amp; len(cfg.errorPaths) == 0 </span><span class="cov6" title="5">{
                server := NewRESTCONFSuccessServer(cfg.successPaths)
                return &amp;mockServerImpl{server: server}
        }</span>

        // Handle simple error-only case
        <span class="cov3" title="2">if len(cfg.errorPaths) &gt; 0 &amp;&amp; len(cfg.successPaths) == 0 </span><span class="cov3" title="2">{
                // Convert error paths map to slice and uniform status code
                paths := make([]string, 0, len(cfg.errorPaths))
                var statusCode int
                for path, status := range cfg.errorPaths </span><span class="cov3" title="2">{
                        paths = append(paths, path)
                        if statusCode == 0 </span><span class="cov3" title="2">{
                                statusCode = status
                        }</span>
                }
                <span class="cov3" title="2">server := NewRESTCONFErrorServer(paths, statusCode)
                return &amp;mockServerImpl{server: server}</span>
        }

        // Mixed case - use advanced server
        <span class="cov0" title="0">return newAdvancedMockServer(cfg)</span>
}

// newAdvancedMockServer creates a server using the flexible RESTCONFServer.
func newAdvancedMockServer(cfg *mockServerConfig) MockServer <span class="cov5" title="4">{
        t := cfg.testing
        if t == nil </span><span class="cov1" title="1">{
                // Create a minimal testing.T substitute for RESTCONFServer requirement
                t = &amp;testing.T{}
        }</span>

        <span class="cov5" title="4">server := NewRESTCONFServer(t)

        // Add success responses
        for path, body := range cfg.successPaths </span><span class="cov3" title="2">{
                server.AddHandler("GET", path, func() (int, string) </span><span class="cov0" title="0">{
                        return 200, body
                }</span>)
        }

        // Add error responses
        <span class="cov5" title="4">for path, statusCode := range cfg.errorPaths </span><span class="cov1" title="1">{
                server.AddHandler("GET", path, func() (int, string) </span><span class="cov0" title="0">{
                        return statusCode, ""
                }</span>)
        }

        // Add custom responses
        <span class="cov5" title="4">for path, config := range cfg.customResponses </span><span class="cov4" title="3">{
                method := config.Method
                if method == "" </span><span class="cov0" title="0">{
                        method = "GET"
                }</span>
                <span class="cov4" title="3">server.AddHandler(method, path, func() (int, string) </span><span class="cov0" title="0">{
                        return config.StatusCode, config.Body
                }</span>)
        }

        <span class="cov5" title="4">return &amp;mockServerImpl{server: server.Server}</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package afc

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/afc"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides AFC (Automated Frequency Coordination) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new AFC service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves the complete AFC operational data.
func (s Service) GetOperational(ctx context.Context) (*model.AFCOper, error) <span class="cov5" title="2">{
        return core.Get[model.AFCOper](ctx, s.Client(), routes.AFCOperPath)
}</span>

// ListAPResponses retrieves AFC AP response data.
func (s Service) ListAPResponses(ctx context.Context) (*model.AFCOperEwlcAFCApResp, error) <span class="cov1" title="1">{
        return core.Get[model.AFCOperEwlcAFCApResp](ctx, s.Client(), routes.AFCEwlcAFCApRespPath)
}</span>

// GetCloudInfo retrieves AFC cloud operational data.
func (s Service) GetCloudInfo(ctx context.Context) (*model.AFCCloudOper, error) <span class="cov1" title="1">{
        return core.Get[model.AFCCloudOper](ctx, s.Client(), routes.AFCCloudOperPath)
}</span>

// GetCloudStats retrieves AFC cloud statistics.
func (s Service) GetCloudStats(ctx context.Context) (*model.AFCCloudOperAFCCloudStats, error) <span class="cov1" title="1">{
        return core.Get[model.AFCCloudOperAFCCloudStats](ctx, s.Client(), routes.AFCAfcCloudStatsPath)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package ap

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        ierrors "github.com/umatare5/cisco-ios-xe-wireless-go/internal/errors"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/ap"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/validation"
)

// Service provides access point operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new AP service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="14">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves the complete AP configuration data.
func (s Service) GetConfig(ctx context.Context) (*model.ApCfg, error) <span class="cov3" title="2">{
        return core.Get[model.ApCfg](ctx, s.Client(), routes.APCfgPath)
}</span>

// ListTagConfigs retrieves access point tag configurations.
func (s Service) ListTagConfigs(ctx context.Context) (*model.ApCfgApTag, error) <span class="cov1" title="1">{
        return core.Get[model.ApCfgApTag](ctx, s.Client(), routes.APTagsPath)
}</span>

// GetTagConfigByMAC retrieves AP tag configuration filtered by AP MAC address.
func (s Service) GetTagConfigByMAC(ctx context.Context, mac string) (*model.ApCfgApTag, error) <span class="cov3" title="2">{
        if err := validation.ValidateMACAddress(mac); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf(ErrInvalidAPMacFormat, mac)
        }</span>
        <span class="cov1" title="1">normalizedMAC, err := validation.NormalizeMACAddress(mac)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(ErrInvalidAPMacFormat, mac)
        }</span>

        // Build correct RESTCONF path: /ap-cfg-data/ap-tags/ap-tag=MAC
        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.APTagQueryPath, normalizedMAC)
        return core.Get[model.ApCfgApTag](ctx, s.Client(), url)</span>
}

// ListTagSourcePriorityConfigs retrieves tag source priority configurations.
func (s Service) ListTagSourcePriorityConfigs(ctx context.Context) (*model.TagSourcePriorityConfigs, error) <span class="cov1" title="1">{
        return core.Get[model.TagSourcePriorityConfigs](ctx, s.Client(), routes.APTagSourcePriorityConfigsPath)
}</span>

// GetTagSourcePriorityConfigByPriority retrieves tag source priority configuration filtered by priority.
func (s Service) GetTagSourcePriorityConfigByPriority(
        ctx context.Context,
        priority int,
) (*model.ApCfgTagSourcePriorityConfigs, error) <span class="cov1" title="1">{
        url := s.Client().RESTCONFBuilder().BuildQueryURL(
                routes.APTagSourcePriorityConfigQueryPath,
                strconv.Itoa(priority),
        )
        return core.Get[model.ApCfgTagSourcePriorityConfigs](ctx, s.Client(), url)
}</span>

// GetGlobalInfo retrieves the complete AP global operational data.
func (s Service) GetGlobalInfo(ctx context.Context) (*model.ApGlobalOper, error) <span class="cov1" title="1">{
        return core.Get[model.ApGlobalOper](ctx, s.Client(), routes.APGlobalOperPath)
}</span>

// GetEWLCAPStats retrieves EWLC AP statistics.
func (s Service) GetEWLCAPStats(ctx context.Context) (*model.ApGlobalOperEwlcApStats, error) <span class="cov1" title="1">{
        return core.Get[model.ApGlobalOperEwlcApStats](ctx, s.Client(), routes.APEwlcApStatsPath)
}</span>

// ListAPHistoryByEthernetMAC retrieves AP history data filtered by ethernet MAC address.
func (s Service) ListAPHistoryByEthernetMAC(
        ctx context.Context,
        ethernetMAC string,
) (*model.ApGlobalOperApHistory, error) <span class="cov4" title="3">{
        if ethernetMAC == "" </span><span class="cov1" title="1">{
                return nil, core.ErrResourceNotFound
        }</span>
        <span class="cov3" title="2">if strings.TrimSpace(ethernetMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrResourceNotFound
        }</span>

        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.APHistoryQueryPath, ethernetMAC)
        return core.Get[model.ApGlobalOperApHistory](ctx, s.Client(), url)</span>
}

// GetAPJoinStatsByWTPMAC retrieves AP join statistics filtered by WTP MAC address.
func (s Service) GetAPJoinStatsByWTPMAC(
        ctx context.Context, mac string,
) (*model.ApGlobalOperApJoinStats, error) <span class="cov4" title="3">{
        if mac == "" </span><span class="cov1" title="1">{
                return nil, core.ErrResourceNotFound
        }</span>
        <span class="cov3" title="2">if strings.TrimSpace(mac) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrResourceNotFound
        }</span>

        <span class="cov1" title="1">normalizedMAC, err := validation.NormalizeMACAddress(mac)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid MAC address %s: %w", mac, err)
        }</span>

        // Build URL with RESTCONF path for ap-join-stats filtered by wtp-mac
        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryURL(
                routes.APJoinStatsPath,
                normalizedMAC,
        )
        return core.Get[model.ApGlobalOperApJoinStats](ctx, s.Client(), url)</span>
}

// GetWLANClientStatsByWLANID retrieves WLAN client statistics filtered by WLAN ID.
func (s Service) GetWLANClientStatsByWLANID(
        ctx context.Context,
        wlanID int,
) (*model.ApGlobalOperWlanClientStats, error) <span class="cov4" title="3">{
        if wlanID &lt;= 0 </span><span class="cov3" title="2">{
                return nil, core.ErrResourceNotFound
        }</span>
        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryURL(
                routes.APWlanClientStatsQueryPath,
                strconv.Itoa(wlanID),
        )
        return core.Get[model.ApGlobalOperWlanClientStats](ctx, s.Client(), url)</span>
}

// ListAPHistory retrieves only AP history data using fields parameter.
func (s Service) ListAPHistory(ctx context.Context) (*model.ApGlobalOperApHistory, error) <span class="cov1" title="1">{
        return core.Get[model.ApGlobalOperApHistory](ctx, s.Client(), routes.APHistoryPath)
}</span>

// ListAPJoinStats retrieves only AP join statistics using fields parameter.
func (s Service) ListAPJoinStats(ctx context.Context) (*model.ApGlobalOperApJoinStats, error) <span class="cov1" title="1">{
        return core.Get[model.ApGlobalOperApJoinStats](ctx, s.Client(), routes.APJoinStatsPath)
}</span>

// ListWLANClientStats retrieves only WLAN client statistics using fields parameter.
func (s Service) ListWLANClientStats(
        ctx context.Context,
) (*model.ApGlobalOperWlanClientStats, error) <span class="cov1" title="1">{
        return core.Get[model.ApGlobalOperWlanClientStats](ctx, s.Client(), routes.APWlanClientStatsPath)
}</span>

// GetOperational retrieves the complete AP operational data.
func (s Service) GetOperational(ctx context.Context) (*model.ApOper, error) <span class="cov1" title="1">{
        return core.Get[model.ApOper](ctx, s.Client(), routes.APOperPath)
}</span>

// ListCAPWAPData retrieves CAPWAP protocol data.
func (s Service) ListCAPWAPData(ctx context.Context) (*model.ApOperCAPWAPData, error) <span class="cov7" title="6">{
        return core.Get[model.ApOperCAPWAPData](ctx, s.Client(), routes.APCapwapDataPath)
}</span>

// GetCAPWAPDataByWTPMAC retrieves CAPWAP data for a specific WTP MAC.
func (s Service) GetCAPWAPDataByWTPMAC(ctx context.Context, wtpMAC string) (*model.ApOperCAPWAPData, error) <span class="cov3" title="2">{
        if wtpMAC == "" || strings.TrimSpace(wtpMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrResourceNotFound
        }</span>

        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.APCapwapDataPath, wtpMAC)
        return core.Get[model.ApOperCAPWAPData](ctx, s.Client(), url)</span>
}

// ListNameMACMaps retrieves AP name-to-MAC mapping data.
func (s Service) ListNameMACMaps(ctx context.Context) (*model.ApOperApNameMACMap, error) <span class="cov1" title="1">{
        return core.Get[model.ApOperApNameMACMap](ctx, s.Client(), routes.APApNameMACMapPath)
}</span>

// GetNameMACMapByWTPName retrieves AP name-to-MAC mapping filtered by WTP name.
func (s Service) GetNameMACMapByWTPName(ctx context.Context, wtpName string) (*model.ApOperApNameMACMap, error) <span class="cov4" title="3">{
        if wtpName == "" </span><span class="cov1" title="1">{
                return nil, core.ErrResourceNotFound
        }</span>
        <span class="cov3" title="2">if strings.TrimSpace(wtpName) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrResourceNotFound
        }</span>

        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.APApNameMACMapPath, wtpName)
        return core.Get[model.ApOperApNameMACMap](ctx, s.Client(), url)</span>
}

// ListRadioStatus retrieves radio operational status data.
func (s Service) ListRadioStatus(ctx context.Context) (*model.RadioOperData, error) <span class="cov1" title="1">{
        return core.Get[model.RadioOperData](ctx, s.Client(), routes.APRadioOperDataPath)
}</span>

// GetRadioStatusByWTPMACAndSlot retrieves radio operational data by WTP MAC and slot ID.
func (s Service) GetRadioStatusByWTPMACAndSlot(
        ctx context.Context, wtpMAC string, slotID int,
) (*model.ApOperRadioOperData, error) <span class="cov4" title="3">{
        if wtpMAC == "" </span><span class="cov1" title="1">{
                return nil, core.ErrResourceNotFound
        }</span>
        <span class="cov3" title="2">if strings.TrimSpace(wtpMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrResourceNotFound
        }</span>

        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryCompositeURL(routes.APRadioOperDataPath, wtpMAC, slotID)
        return core.Get[model.ApOperRadioOperData](ctx, s.Client(), url)</span>
}

// ListRadioNeighbors retrieves all AP radio neighbor information.
func (s Service) ListRadioNeighbors(ctx context.Context) (*model.ApOperApRadioNeighbor, error) <span class="cov1" title="1">{
        return core.Get[model.ApOperApRadioNeighbor](ctx, s.Client(), routes.APRadioNeighborPath)
}</span>

// GetRadioNeighborByAPMACSlotAndBSSID retrieves AP radio neighbor information for a specific AP MAC, slot ID and BSSID.
// This follows the YANG model key structure: "ap-mac slot-id bssid".
func (s Service) GetRadioNeighborByAPMACSlotAndBSSID(
        ctx context.Context, apMAC string, slotID int, bssid string,
) (*model.ApOperApRadioNeighbor, error) <span class="cov5" title="4">{
        if apMAC == "" || strings.TrimSpace(apMAC) == "" </span><span class="cov1" title="1">{
                return nil, errors.New("AP MAC address cannot be empty")
        }</span>
        <span class="cov4" title="3">if bssid == "" || strings.TrimSpace(bssid) == "" </span><span class="cov1" title="1">{
                return nil, errors.New("BSSID cannot be empty")
        }</span>

        <span class="cov3" title="2">if err := validation.ValidateMACAddress(apMAC); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid AP MAC address: %w", err)
        }</span>
        <span class="cov1" title="1">if err := validation.ValidateMACAddress(bssid); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid BSSID: %w", err)
        }</span>

        <span class="cov1" title="1">normalizedAPMAC, err := validation.NormalizeMACAddress(apMAC)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid AP MAC address %s: %w", apMAC, err)
        }</span>
        <span class="cov1" title="1">normalizedBSSID, err := validation.NormalizeMACAddress(bssid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid BSSID %s: %w", bssid, err)
        }</span>

        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryCompositeURL(
                routes.APRadioNeighborPath,
                normalizedAPMAC,
                slotID,
                normalizedBSSID,
        )
        return core.Get[model.ApOperApRadioNeighbor](ctx, s.Client(), url)</span>
}

// ListActiveImageLocations retrieves active image location information using fields parameter.
func (s Service) ListActiveImageLocations(
        ctx context.Context,
) (*model.ApOperApImageActiveLocation, error) <span class="cov1" title="1">{
        return core.Get[model.ApOperApImageActiveLocation](ctx, s.Client(), routes.APImageActiveLocationPath)
}</span>

// ListPreparedImageLocations retrieves only AP image prepare location data using fields parameter.
func (s Service) ListPreparedImageLocations(
        ctx context.Context,
) (*model.ApOperApImagePrepareLocation, error) <span class="cov1" title="1">{
        return core.Get[model.ApOperApImagePrepareLocation](ctx, s.Client(), routes.APImagePrepareLocationPath)
}</span>

// ListPowerInfo retrieves only AP power information using fields parameter.
func (s Service) ListPowerInfo(ctx context.Context) (*model.ApOperApPwrInfo, error) <span class="cov1" title="1">{
        return core.Get[model.ApOperApPwrInfo](ctx, s.Client(), routes.APPwrInfoPath)
}</span>

// ListSensorStatus retrieves only AP sensor status using fields parameter.
func (s Service) ListSensorStatus(ctx context.Context) (*model.ApOperApSensorStatus, error) <span class="cov1" title="1">{
        return core.Get[model.ApOperApSensorStatus](ctx, s.Client(), routes.APSensorStatusPath)
}</span>

// ListCAPWAPPackets retrieves only CAPWAP packets data using fields parameter.
func (s Service) ListCAPWAPPackets(ctx context.Context) (*model.ApOperCAPWAPPkts, error) <span class="cov1" title="1">{
        return core.Get[model.ApOperCAPWAPPkts](ctx, s.Client(), routes.APCapwapPktsPath)
}</span>

// ListIotFirmware retrieves IoT firmware information for all access points.
func (s Service) ListIotFirmware(ctx context.Context) (*model.ApOperIotFirmware, error) <span class="cov1" title="1">{
        return core.Get[model.ApOperIotFirmware](ctx, s.Client(), routes.APIotFirmwarePath)
}</span>

// EnableAP enables the administrative state of an access point.
func (s Service) EnableAP(ctx context.Context, mac string) error <span class="cov4" title="3">{
        return s.updateAPState(ctx, mac, "admin-state-enabled")
}</span>

// DisableAP disables the administrative state of an access point.
func (s Service) DisableAP(ctx context.Context, mac string) error <span class="cov3" title="2">{
        return s.updateAPState(ctx, mac, "admin-state-disabled")
}</span>

// EnableRadio enables a radio on an Access Point using MAC address.
func (s Service) EnableRadio(ctx context.Context, apMAC string, radioBand core.RadioBand) error <span class="cov5" title="4">{
        if err := validation.ValidateMACAddress(apMAC); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov4" title="3">return s.updateRadioState(ctx, apMAC, &amp;radioBand, true)</span>
}

// DisableRadio disables a radio on an Access Point using MAC address.
func (s Service) DisableRadio(ctx context.Context, apMAC string, radioBand core.RadioBand) error <span class="cov3" title="2">{
        if err := validation.ValidateMACAddress(apMAC); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return s.updateRadioState(ctx, apMAC, &amp;radioBand, false)</span>
}

// AssignSiteTag assigns a site tag to an Access Point using MAC address.
func (s Service) AssignSiteTag(ctx context.Context, apMAC, siteTag string) error <span class="cov5" title="4">{
        if !validation.IsValidTagAssignment(siteTag, "site") </span><span class="cov1" title="1">{
                return ierrors.RequiredParameterError("site tag")
        }</span>
        <span class="cov4" title="3">tags := model.ApTag{SiteTag: siteTag}
        return s.assignTags(ctx, apMAC, tags)</span>
}

// AssignPolicyTag assigns a policy tag to an Access Point using MAC address.
func (s Service) AssignPolicyTag(ctx context.Context, apMAC, policyTag string) error <span class="cov3" title="2">{
        if !validation.IsValidTagAssignment(policyTag, "policy") </span><span class="cov1" title="1">{
                return ierrors.RequiredParameterError("policy tag")
        }</span>
        <span class="cov1" title="1">tags := model.ApTag{PolicyTag: policyTag}
        return s.assignTags(ctx, apMAC, tags)</span>
}

// AssignRFTag assigns an RF tag to an Access Point using MAC address.
func (s Service) AssignRFTag(ctx context.Context, apMAC, rfTag string) error <span class="cov3" title="2">{
        if !validation.IsValidTagAssignment(rfTag, "rf") </span><span class="cov1" title="1">{
                return ierrors.RequiredParameterError("RF tag")
        }</span>
        <span class="cov1" title="1">tags := model.ApTag{RFTag: rfTag}
        return s.assignTags(ctx, apMAC, tags)</span>
}

// Reload restarts an Access Point by MAC address causing temporary service interruption.
func (s Service) Reload(ctx context.Context, apMAC string) error <span class="cov7" title="6">{
        if !validation.IsValidMACAddr(apMAC) </span><span class="cov1" title="1">{
                return fmt.Errorf(ErrInvalidAPMacFormat, apMAC)
        }</span>

        <span class="cov6" title="5">resp, err := s.ListCAPWAPData(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf(ErrFailedGetCAPWAPData, err)
        }</span>
        <span class="cov5" title="4">if resp == nil </span><span class="cov0" title="0">{
                return errors.New(ErrCAPWAPDataUnavailable)
        }</span>

        <span class="cov5" title="4">apName, found := findAPByMAC(resp, apMAC)
        if !found </span><span class="cov3" title="2">{
                return fmt.Errorf(ErrAPNotFoundByMAC, apMAC)
        }</span>

        <span class="cov3" title="2">return s.reload(ctx, apName)</span>
}

// updateAPState handles AP admin state changes with mac and mode parameters.
func (s Service) updateAPState(ctx context.Context, mac, mode string) error <span class="cov6" title="5">{
        if err := validation.ValidateMACAddress(mac); err != nil </span><span class="cov3" title="2">{
                return fmt.Errorf("invalid AP MAC address: %s", mac)
        }</span>

        <span class="cov4" title="3">normalizedMAC, err := validation.NormalizeMACAddress(mac)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid AP MAC address: %s", mac)
        }</span>

        <span class="cov4" title="3">payload := model.APConfigRPCPayload{
                Input: model.APConfigRPCInput{
                        Mode:    mode,
                        MACAddr: normalizedMAC,
                },
        }

        if err := core.PostRPCVoid(ctx, s.Client(), routes.APSetApAdminStateRPC, payload); err != nil </span><span class="cov1" title="1">{
                return ierrors.ServiceOperationError("update", "AP", "admin state", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// updateRadioState handles radio-level state changes.
func (s Service) updateRadioState(ctx context.Context, apMAC string, radioBand *core.RadioBand, enabled bool) error <span class="cov5" title="4">{
        if radioBand == nil </span><span class="cov0" title="0">{
                return ierrors.RequiredParameterError("radio band")
        }</span>

        <span class="cov5" title="4">normalizedMAC, err := validation.NormalizeMACAddress(apMAC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid AP MAC address %s: %w", apMAC, err)
        }</span>

        <span class="cov5" title="4">radioBandInfo, err := core.GetRadioBandInfo(int(*radioBand))
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="3">payload := model.APSlotConfigRPCPayload{
                Input: model.APSlotConfigRPCInput{
                        Mode:    core.GetAdminStateMode(enabled),
                        SlotID:  int(radioBandInfo.SlotID),
                        Band:    strconv.Itoa(int(radioBandInfo.Band)),
                        MACAddr: normalizedMAC,
                },
        }

        if err := core.PostRPCVoid(ctx, s.Client(), routes.APSetApSlotAdminStateRPC, payload); err != nil </span><span class="cov1" title="1">{
                return ierrors.ServiceOperationError("set", "AP radio", "state", err)
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// assignTags assigns multiple tags to an Access Point (internal implementation).
func (s Service) assignTags(ctx context.Context, apMAC string, tags model.ApTag) error <span class="cov6" title="5">{
        if !validation.IsValidMACAddr(apMAC) </span><span class="cov1" title="1">{
                return ierrors.ValidationError("AP MAC address", apMAC)
        }</span>
        <span class="cov5" title="4">if !validation.HasValidTags(tags.SiteTag, tags.PolicyTag, tags.RFTag) </span><span class="cov0" title="0">{
                return ierrors.RequiredParameterError("at least one tag")
        }</span>

        <span class="cov5" title="4">normalizedMAC, err := validation.NormalizeMACAddress(apMAC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid AP MAC address %s: %w", apMAC, err)
        }</span>
        <span class="cov5" title="4">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.APTagPath, normalizedMAC)
        tagData := buildAPCfgApTagData(normalizedMAC, tags)

        // Execute operation with direct error propagation
        if err := core.PutVoid(ctx, s.Client(), url, model.APTagPayload{ApTag: tagData}); err != nil </span><span class="cov1" title="1">{
                return ierrors.ServiceOperationError("assign", "AP", "tags", err)
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// reload is the internal helper function for AP reload operations.
func (s Service) reload(ctx context.Context, apName string) error <span class="cov3" title="2">{
        requestBody := model.APReloadRPCPayload{
                Input: model.APReloadRPCInput{
                        APName: apName,
                },
        }
        return core.PostRPCVoid(ctx, s.Client(), routes.APApResetRPC, requestBody)
}</span>

// findAPByMAC searches for an AP with the given MAC address in CAPWAP data.
func findAPByMAC(capwapData *model.ApOperCAPWAPData, apMAC string) (string, bool) <span class="cov5" title="4">{
        if capwapData == nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov5" title="4">for _, data := range capwapData.CAPWAPData </span><span class="cov3" title="2">{
                if data.WtpMAC == apMAC </span><span class="cov3" title="2">{
                        return data.Name, true
                }</span>
        }
        <span class="cov3" title="2">return "", false</span>
}

// buildAPCfgApTagData constructs the payload for tag assignment requests.
func buildAPCfgApTagData(normalizedMAC string, tags model.ApTag) model.APCfgApTagData <span class="cov5" title="4">{
        return model.APCfgApTagData{
                APMac:     normalizedMAC,
                SiteTag:   validation.SelectNonEmptyValue(tags.SiteTag, validation.DefaultSiteTag),
                PolicyTag: validation.SelectNonEmptyValue(tags.PolicyTag, validation.DefaultPolicyTag),
                RFTag:     validation.SelectNonEmptyValue(tags.RFTag, validation.DefaultRFTag),
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package apf

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/apf"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides APF (Application Policy Framework) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new APF service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves the complete APF configuration data.
func (s Service) GetConfig(ctx context.Context) (*model.APFCfg, error) <span class="cov5" title="2">{
        return core.Get[model.APFCfg](ctx, s.Client(), routes.APFCfgPath)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package awips

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/awips"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides AWIPS (Automated Wireless IPS) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new AWIPS service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves the complete AWIPS operational data.
func (s Service) GetOperational(ctx context.Context) (*model.AWIPSOper, error) <span class="cov5" title="2">{
        return core.Get[model.AWIPSOper](ctx, s.Client(), routes.AWIPSOperPath)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package ble

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/ble"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides BLE (Bluetooth Low Energy) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new BLE service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves BLE operational data from the controller.
func (s Service) GetOperational(ctx context.Context) (*model.BLELtxOper, error) <span class="cov5" title="2">{
        return core.Get[model.BLELtxOper](ctx, s.Client(), routes.BLELtxOperPath)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package client

import (
        "context"
        "strings"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/client"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides wireless client operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Client service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="11">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves the complete client operational data.
func (s Service) GetOperational(ctx context.Context) (*model.ClientOper, error) <span class="cov6" title="4">{
        result, err := core.Get[model.ClientOper](ctx, s.Client(), routes.ClientOperPath)
        if err == nil </span><span class="cov1" title="1">{
                return result, nil
        }</span>
        <span class="cov5" title="3">if isKnownGetOperationalIssue(err) </span><span class="cov1" title="1">{
                // Return empty result for IOS-XE 17.18.1 compatibility
                // Known issue: main endpoint may fail intermittently on certain firmware versions
                return &amp;model.ClientOper{}, nil
        }</span>
        <span class="cov3" title="2">return nil, err</span>
}

// ListCommonInfo retrieves common operational data for clients.
func (s Service) ListCommonInfo(ctx context.Context) (*model.ClientOperCommonOperData, error) <span class="cov1" title="1">{
        return core.Get[model.ClientOperCommonOperData](ctx, s.Client(), routes.ClientCommonOperDataPath)
}</span>

// GetCommonInfoByMAC retrieves client operational data filtered by MAC address.
func (s Service) GetCommonInfoByMAC(
        ctx context.Context, mac string,
) (*model.ClientOperCommonOperData, error) <span class="cov3" title="2">{
        if mac == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.ClientCommonOperDataPath, mac)
        return core.Get[model.ClientOperCommonOperData](ctx, s.Client(), url)</span>
}

// ListDCInfo retrieves discovery client information.
func (s Service) ListDCInfo(ctx context.Context) (*model.ClientOperDcInfo, error) <span class="cov1" title="1">{
        return core.Get[model.ClientOperDcInfo](ctx, s.Client(), routes.ClientDcInfoPath)
}</span>

// GetDCInfoByMAC retrieves dc-info for a specific client by MAC address.
func (s Service) GetDCInfoByMAC(ctx context.Context, clientMAC string) (*model.ClientOperDcInfo, error) <span class="cov3" title="2">{
        if clientMAC == "" || strings.TrimSpace(clientMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov1" title="1">endpoint := s.Client().RESTCONFBuilder().BuildQueryURL(routes.ClientDcInfoPath, clientMAC)
        return core.Get[model.ClientOperDcInfo](ctx, s.Client(), endpoint)</span>
}

// ListDot11Info returns 802.11 operational data for clients.
func (s Service) ListDot11Info(ctx context.Context) (*model.ClientOperDot11OperData, error) <span class="cov7" title="5">{
        result, err := core.Get[model.ClientOperDot11OperData](ctx, s.Client(), routes.ClientDot11OperDataPath)
        if err == nil </span><span class="cov3" title="2">{
                return result, nil
        }</span>
        <span class="cov5" title="3">if isKnownDot11OperationalDataIssue(err) </span><span class="cov3" title="2">{
                // Return empty result for IOS-XE 17.18.1 compatibility
                // Known issue: endpoint may fail even after client connections and 90-second wait period
                return &amp;model.ClientOperDot11OperData{Dot11OperData: []model.Dot11OperData{}}, nil
        }</span>
        <span class="cov1" title="1">return nil, err</span>
}

// GetDot11InfoByMAC retrieves 802.11 operational data filtered by MAC address.
func (s Service) GetDot11InfoByMAC(ctx context.Context, mac string) (*model.ClientOperDot11OperData, error) <span class="cov7" title="5">{
        if mac == "" || strings.TrimSpace(mac) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov6" title="4">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.ClientDot11OperDataPath, mac)

        result, err := core.Get[model.ClientOperDot11OperData](ctx, s.Client(), url)
        if err == nil </span><span class="cov1" title="1">{
                return result, nil
        }</span>
        <span class="cov5" title="3">if isKnownDot11OperationalDataIssue(err) </span><span class="cov3" title="2">{
                // Return empty result for IOS-XE 17.18.1 compatibility
                // Known issue: endpoint may fail even after client connections and 90-second wait period
                return &amp;model.ClientOperDot11OperData{Dot11OperData: []model.Dot11OperData{}}, nil
        }</span>
        <span class="cov1" title="1">return nil, err</span>
}

// ListMMIFClientHistory retrieves mobility manager interface client history.
func (s Service) ListMMIFClientHistory(ctx context.Context) (*model.ClientOperMmIfClientHistory, error) <span class="cov1" title="1">{
        return core.Get[model.ClientOperMmIfClientHistory](ctx, s.Client(), routes.ClientMmIfClientHistoryPath)
}</span>

// GetMMIFClientHistoryByMAC retrieves mm-if-client-history for a specific client by MAC address.
func (s Service) GetMMIFClientHistoryByMAC(
        ctx context.Context,
        clientMAC string,
) (*model.ClientOperMmIfClientHistory, error) <span class="cov3" title="2">{
        if clientMAC == "" || strings.TrimSpace(clientMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov1" title="1">endpoint := s.Client().RESTCONFBuilder().BuildQueryURL(routes.ClientMmIfClientHistoryPath, clientMAC)
        return core.Get[model.ClientOperMmIfClientHistory](ctx, s.Client(), endpoint)</span>
}

// ListMMIFClientStats retrieves mobility manager interface client statistics.
func (s Service) ListMMIFClientStats(ctx context.Context) (*model.ClientOperMmIfClientStats, error) <span class="cov1" title="1">{
        return core.Get[model.ClientOperMmIfClientStats](ctx, s.Client(), routes.ClientMmIfClientStatsPath)
}</span>

// GetMMIFClientStatsByMAC retrieves mm-if-client-stats for a specific client by MAC address.
func (s Service) GetMMIFClientStatsByMAC(
        ctx context.Context,
        clientMAC string,
) (*model.ClientOperMmIfClientStats, error) <span class="cov3" title="2">{
        if clientMAC == "" || strings.TrimSpace(clientMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov1" title="1">endpoint := s.Client().RESTCONFBuilder().BuildQueryURL(routes.ClientMmIfClientStatsPath, clientMAC)
        return core.Get[model.ClientOperMmIfClientStats](ctx, s.Client(), endpoint)</span>
}

// ListMobilityInfo retrieves mobility operational data for clients.
func (s Service) ListMobilityInfo(ctx context.Context) (*model.ClientOperMobilityOperData, error) <span class="cov1" title="1">{
        return core.Get[model.ClientOperMobilityOperData](ctx, s.Client(), routes.ClientMobilityOperDataPath)
}</span>

// GetMobilityInfoByMAC retrieves mobility-oper-data for a specific client by MAC address.
func (s Service) GetMobilityInfoByMAC(
        ctx context.Context,
        clientMAC string,
) (*model.ClientOperMobilityOperData, error) <span class="cov3" title="2">{
        if clientMAC == "" || strings.TrimSpace(clientMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov1" title="1">endpoint := s.Client().RESTCONFBuilder().BuildQueryURL(routes.ClientMobilityOperDataPath, clientMAC)
        return core.Get[model.ClientOperMobilityOperData](ctx, s.Client(), endpoint)</span>
}

// ListPolicyInfo retrieves client policy data.
func (s Service) ListPolicyInfo(ctx context.Context) (*model.ClientOperPolicyData, error) <span class="cov1" title="1">{
        return core.Get[model.ClientOperPolicyData](ctx, s.Client(), routes.ClientPolicyDataPath)
}</span>

// GetPolicyInfoByMAC retrieves policy-data for a specific client by MAC address.
func (s Service) GetPolicyInfoByMAC(ctx context.Context, clientMAC string) (*model.ClientOperPolicyData, error) <span class="cov3" title="2">{
        if clientMAC == "" || strings.TrimSpace(clientMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov1" title="1">endpoint := s.Client().RESTCONFBuilder().BuildQueryURL(routes.ClientPolicyDataPath, clientMAC)
        return core.Get[model.ClientOperPolicyData](ctx, s.Client(), endpoint)</span>
}

// ListSISFDB retrieves SISF database MAC information.
func (s Service) ListSISFDB(ctx context.Context) (*model.ClientOperSisfDBMac, error) <span class="cov1" title="1">{
        return core.Get[model.ClientOperSisfDBMac](ctx, s.Client(), routes.ClientSisfDBMacPath)
}</span>

// GetSISFDBByMAC retrieves sisf-db-mac for a specific client by MAC address.
func (s Service) GetSISFDBByMAC(ctx context.Context, clientMAC string) (*model.ClientOperSisfDBMac, error) <span class="cov3" title="2">{
        if clientMAC == "" || strings.TrimSpace(clientMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov1" title="1">endpoint := s.Client().RESTCONFBuilder().BuildQueryURL(routes.ClientSisfDBMacPath, clientMAC)
        return core.Get[model.ClientOperSisfDBMac](ctx, s.Client(), endpoint)</span>
}

// ListTrafficStats retrieves client traffic statistics.
func (s Service) ListTrafficStats(ctx context.Context) (*model.ClientOperTrafficStats, error) <span class="cov1" title="1">{
        return core.Get[model.ClientOperTrafficStats](ctx, s.Client(), routes.ClientTrafficStatsPath)
}</span>

// GetTrafficStatsByMAC retrieves traffic-stats for a specific client by MAC address.
func (s Service) GetTrafficStatsByMAC(
        ctx context.Context,
        clientMAC string,
) (*model.ClientOperTrafficStats, error) <span class="cov3" title="2">{
        if clientMAC == "" || strings.TrimSpace(clientMAC) == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov1" title="1">endpoint := s.Client().RESTCONFBuilder().BuildQueryURL(routes.ClientTrafficStatsPath, clientMAC)
        return core.Get[model.ClientOperTrafficStats](ctx, s.Client(), endpoint)</span>
}

// isKnownGetOperationalIssue checks if the error is a known IOS-XE 17.18.1 compatibility issue
// specific to the GetOperational method (main client operational data endpoint).
func isKnownGetOperationalIssue(err error) bool <span class="cov5" title="3">{
        errorMsg := err.Error()
        // Known IOS-XE 17.18.1 GetOperational issues that require empty response fallback
        return strings.Contains(errorMsg, "unexpected EOF")
}</span>

// isKnownDot11OperationalDataIssue checks if the error is a known IOS-XE 17.18.1 compatibility issue
// specific to the Dot11OperationalData methods (802.11 operational data endpoint).
func isKnownDot11OperationalDataIssue(err error) bool <span class="cov7" title="6">{
        errorMsg := err.Error()
        // Known IOS-XE 17.18.1 Dot11OperationalData issues that require empty response fallback
        return strings.Contains(errorMsg, "failed to retrieve table cursor") ||
                strings.Contains(errorMsg, "Process DBAL response failed")
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package controller

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/controller"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides controller management operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Controller service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="5">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// Reload restarts the WNC controller causing temporary service interruption.
func (s Service) Reload(ctx context.Context, reason string, force bool) error <span class="cov8" title="4">{
        if strings.TrimSpace(reason) == "" </span><span class="cov4" title="2">{
                return errors.New(ErrInvalidReloadReason)
        }</span>

        <span class="cov4" title="2">return s.reload(ctx, reason, &amp;force)</span>
}

// ReloadWithReason restarts the WNC controller with the specified reason only.
func (s Service) ReloadWithReason(ctx context.Context, reason string) error <span class="cov8" title="4">{
        if strings.TrimSpace(reason) == "" </span><span class="cov4" title="2">{
                return errors.New(ErrInvalidReloadReason)
        }</span>

        <span class="cov4" title="2">return s.reload(ctx, reason, nil)</span>
}

// reload is the internal helper function for WNC controller reload operations.
func (s Service) reload(ctx context.Context, reason string, force *bool) error <span class="cov8" title="4">{
        requestBody := model.WNCReloadRPCPayload{
                Input: model.WNCReloadRPCInput{
                        Reason: reason,
                        Force:  force,
                },
        }

        err := core.PostRPCVoid(ctx, s.Client(), routes.ControllerReloadRPC, requestBody)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("controller reload operation failed: %w",
                        fmt.Errorf("reload RPC execution failed: %w", err))
        }</span>

        <span class="cov7" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package cts

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/cts"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides CTS (Cisco TrustSec) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new CTS service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves CTS configuration data from the controller.
func (s Service) GetConfig(ctx context.Context) (*model.CTSCfg, error) <span class="cov5" title="2">{
        return core.Get[model.CTSCfg](ctx, s.Client(), routes.CTSCfgPath)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package dot11

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/dot11"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides IEEE 802.11 wireless configuration operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new 802.11 service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves dot11 configuration data from the controller.
func (s Service) GetConfig(ctx context.Context) (*model.Dot11Cfg, error) <span class="cov5" title="2">{
        return core.Get[model.Dot11Cfg](ctx, s.Client(), routes.Dot11CfgPath)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package dot15

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/dot15"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides IEEE 802.15 Bluetooth configuration operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new 802.15 service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves dot15.4 configuration data from the controller.
func (s Service) GetConfig(ctx context.Context) (*model.Dot15Cfg, error) <span class="cov5" title="2">{
        return core.Get[model.Dot15Cfg](ctx, s.Client(), routes.Dot15CfgPath)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package fabric

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/fabric"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides SD-Access Fabric operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Fabric service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves Fabric configuration data.
func (s Service) GetConfig(ctx context.Context) (*model.FabricCfg, error) <span class="cov5" title="2">{
        return core.Get[model.FabricCfg](ctx, s.Client(), routes.FabricCfgPath)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package flex

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/flex"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides FlexConnect operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new FlexConnect service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves FlexConnect configuration data.
func (s Service) GetConfig(ctx context.Context) (*model.FlexCfg, error) <span class="cov5" title="2">{
        return core.Get[model.FlexCfg](ctx, s.Client(), routes.FlexCfgPath)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package general

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/general"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides general system information operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new General service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="9">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves general operational data.
func (s Service) GetOperational(ctx context.Context) (*model.GeneralOper, error) <span class="cov3" title="2">{
        return core.Get[model.GeneralOper](ctx, s.Client(), routes.GeneralOperPath)
}</span>

// GetManagementInterfaceState retrieves management interface operational data.
func (s Service) GetManagementInterfaceState(ctx context.Context) (*model.GeneralOperMgmtIntfData, error) <span class="cov3" title="2">{
        return core.Get[model.GeneralOperMgmtIntfData](ctx, s.Client(), routes.GeneralMgmtIntfDataPath)
}</span>

// GetConfig retrieves complete general configuration data from the controller.
func (s Service) GetConfig(ctx context.Context) (*model.GeneralCfg, error) <span class="cov3" title="2">{
        return core.Get[model.GeneralCfg](ctx, s.Client(), routes.GeneralCfgPath)
}</span>

// Configuration data retrieval methods

// GetAPLocationRangingConfig retrieves AP location ranging configuration data.
func (s Service) GetAPLocationRangingConfig(ctx context.Context) (*model.ApLocRangingCfg, error) <span class="cov1" title="1">{
        return core.Get[model.ApLocRangingCfg](ctx, s.Client(), routes.GeneralApLocRangingCfgPath)
}</span>

// GetCACConfig retrieves CAC configuration data.
func (s Service) GetCACConfig(ctx context.Context) (*model.CacConfig, error) <span class="cov1" title="1">{
        return core.Get[model.CacConfig](ctx, s.Client(), routes.GeneralCacConfigPath)
}</span>

// GetFeatureUsageConfig retrieves feature usage configuration data.
func (s Service) GetFeatureUsageConfig(ctx context.Context) (*model.FeatureUsageCfg, error) <span class="cov1" title="1">{
        return core.Get[model.FeatureUsageCfg](ctx, s.Client(), routes.GeneralFeatureUsageCfgPath)
}</span>

// GetFIPSConfig retrieves FIPS configuration data.
func (s Service) GetFIPSConfig(ctx context.Context) (*model.FipsCfg, error) <span class="cov1" title="1">{
        return core.Get[model.FipsCfg](ctx, s.Client(), routes.GeneralFipsCfgPath)
}</span>

// GetGeolocationConfig retrieves geolocation configuration data.
func (s Service) GetGeolocationConfig(ctx context.Context) (*model.GeolocationCfg, error) <span class="cov1" title="1">{
        return core.Get[model.GeolocationCfg](ctx, s.Client(), routes.GeneralGeolocationCfgPath)
}</span>

// GetLAGInfo retrieves LAG (Link Aggregation) information.
func (s Service) GetLAGInfo(ctx context.Context) (*model.Laginfo, error) <span class="cov3" title="2">{
        return core.Get[model.Laginfo](ctx, s.Client(), routes.GeneralLaginfoPath)
}</span>

// GetMEWLCConfig retrieves MEWLC configuration data.
func (s Service) GetMEWLCConfig(ctx context.Context) (*model.MewlcConfig, error) <span class="cov1" title="1">{
        return core.Get[model.MewlcConfig](ctx, s.Client(), routes.GeneralMewlcConfigPath)
}</span>

// GetMFPConfig retrieves MFP (Management Frame Protection) configuration data.
func (s Service) GetMFPConfig(ctx context.Context) (*model.Mfp, error) <span class="cov3" title="2">{
        return core.Get[model.Mfp](ctx, s.Client(), routes.GeneralMfpPath)
}</span>

// GetMulticastConfig retrieves multicast configuration data.
func (s Service) GetMulticastConfig(ctx context.Context) (*model.MulticastConfig, error) <span class="cov1" title="1">{
        return core.Get[model.MulticastConfig](ctx, s.Client(), routes.GeneralMulticastConfigPath)
}</span>

// ListSIML3InterfaceCache returns SIM L3 interface cache data.
func (s Service) ListSIML3InterfaceCache(ctx context.Context) (*model.SimL3InterfaceCacheData, error) <span class="cov1" title="1">{
        return core.Get[model.SimL3InterfaceCacheData](ctx, s.Client(), routes.GeneralSimL3InterfaceCacheDataPath)
}</span>

// GetThresholdWarningConfig retrieves threshold warning configuration data.
func (s Service) GetThresholdWarningConfig(ctx context.Context) (*model.ThresholdWarnCfg, error) <span class="cov1" title="1">{
        return core.Get[model.ThresholdWarnCfg](ctx, s.Client(), routes.GeneralThresholdWarnCfgPath)
}</span>

// GetWLCManagementInfo retrieves WLC management data.
func (s Service) GetWLCManagementInfo(ctx context.Context) (*model.WlcManagementData, error) <span class="cov1" title="1">{
        return core.Get[model.WlcManagementData](ctx, s.Client(), routes.GeneralWlcManagementDataPath)
}</span>

// GetWSAAPClientEventConfig retrieves WSA AP client event configuration data.
func (s Service) GetWSAAPClientEventConfig(ctx context.Context) (*model.WsaApClientEvent, error) <span class="cov1" title="1">{
        return core.Get[model.WsaApClientEvent](ctx, s.Client(), routes.GeneralWsaApClientEventPath)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package geolocation

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/geolocation"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides geolocation tracking operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Geolocation service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves geolocation operational data from the controller.
func (s Service) GetOperational(ctx context.Context) (*model.GeolocationOper, error) <span class="cov5" title="2">{
        return core.Get[model.GeolocationOper](ctx, s.Client(), routes.GeolocationOperPath)
}</span>

// ListAPGeolocationStats retrieves AP geolocation statistics.
func (s Service) ListAPGeolocationStats(ctx context.Context) (*model.GeolocationOperApGeoLocStats, error) <span class="cov1" title="1">{
        return core.Get[model.GeolocationOperApGeoLocStats](ctx, s.Client(), routes.GeolocationApGeoLocStatsPath)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package hyperlocation

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/hyperlocation"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides Hyperlocation operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Hyperlocation service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves hyperlocation operational data from the controller.
func (s Service) GetOperational(ctx context.Context) (*model.HyperlocationOper, error) <span class="cov5" title="2">{
        return core.Get[model.HyperlocationOper](ctx, s.Client(), routes.HyperlocationOperPath)
}</span>

// ListProfiles retrieves hyperlocation profiles.
func (s Service) ListProfiles(ctx context.Context) (*model.HyperlocationProfiles, error) <span class="cov5" title="2">{
        return core.Get[model.HyperlocationProfiles](ctx, s.Client(), routes.HyperlocationProfilesPath)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package lisp

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/lisp"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides LISP (Locator/ID Separation Protocol) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new LISP service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="7">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves LISP operational data from the wireless controller.
func (s Service) GetOperational(ctx context.Context) (*model.LISPAgentOper, error) <span class="cov6" title="3">{
        return core.Get[model.LISPAgentOper](ctx, s.Client(), routes.LISPOperPath)
}</span>

// GetMemoryStats retrieves LISP agent memory statistics from the wireless controller.
func (s Service) GetMemoryStats(ctx context.Context) (*model.LISPAgentMemoryStats, error) <span class="cov6" title="3">{
        return core.Get[model.LISPAgentMemoryStats](ctx, s.Client(), routes.LISPMemoryStatsPath)
}</span>

// GetCapabilities retrieves LISP WLC capabilities from the wireless controller.
func (s Service) GetCapabilities(ctx context.Context) (*model.LISPWLCCapabilities, error) <span class="cov6" title="3">{
        return core.Get[model.LISPWLCCapabilities](ctx, s.Client(), routes.LISPCapabilitiesPath)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package location

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/location"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides location services operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Location service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="8">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves complete location configuration data from the wireless controller.
func (s Service) GetConfig(ctx context.Context) (*model.LocationCfg, error) <span class="cov5" title="3">{
        return core.Get[model.LocationCfg](ctx, s.Client(), routes.LocationCfgPath)
}</span>

// ListOperatorLocations retrieves location profile configuration data from the wireless controller.
func (s Service) ListOperatorLocations(ctx context.Context) (*model.OperatorLocations, error) <span class="cov4" title="2">{
        return core.Get[model.OperatorLocations](ctx, s.Client(), routes.LocationOperatorLocationsPath)
}</span>

// ListNMSPConfig retrieves location NMSP configuration data from the wireless controller.
func (s Service) ListNMSPConfig(ctx context.Context) (*model.LocationCfgNMSPConfig, error) <span class="cov4" title="2">{
        return core.Get[model.LocationCfgNMSPConfig](ctx, s.Client(), routes.LocationNMSPConfigPath)
}</span>

// GetLocation retrieves location settings configuration data from the wireless controller.
func (s Service) GetLocation(ctx context.Context) (*model.LocationSettings, error) <span class="cov1" title="1">{
        return core.Get[model.LocationSettings](ctx, s.Client(), routes.LocationPath)
}</span>

// GetOperational retrieves all location operational data from the wireless controller.
func (s Service) GetOperational(ctx context.Context) (*model.LocationOper, error) <span class="cov1" title="1">{
        return core.Get[model.LocationOper](ctx, s.Client(), routes.LocationOperPath)
}</span>

// LocationRSSIMeasurements retrieves location statistics operational data from the wireless controller.
func (s Service) LocationRSSIMeasurements(ctx context.Context) (*model.LocationLocationRSSIMeasurements, error) <span class="cov1" title="1">{
        return core.Get[model.LocationLocationRSSIMeasurements](ctx, s.Client(), routes.LocationRSSIMeasurementsPath)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package mcast

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/mcast"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides multicast management operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Multicast service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="5">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves multicast operational data from the controller.
func (s Service) GetOperational(ctx context.Context) (*model.McastOper, error) <span class="cov7" title="3">{
        return core.Get[model.McastOper](ctx, s.Client(), routes.McastOperPath)
}</span>

// GetFlexConnectMediastreamClientSummary retrieves FlexConnect mediastream client summary data from the wireless controller.
// This function returns information about FlexConnect mediastream clients and their status.
//
// Parameters:
//   - ctx: Context for request timeout and cancellation control
//
// Returns:
//   - *model.McastOperFlexMediastreamClientSummary: FlexConnect mediastream data
//   - error: Error if the operation fails
//
// Example:
//
//        service := mcast.NewService(client)
//        data, err := service.GetFlexConnectMediastreamClientSummary(ctx)
//        if err != nil {
//            log.Fatal(err)
//        }
//        fmt.Printf("FlexConnect mediastream data: %+v\n", data)
func (s Service) GetFlexConnectMediastreamClientSummary(
        ctx context.Context,
) (*model.McastOperFlexMediastreamClientSummary, error) <span class="cov7" title="3">{
        return core.Get[model.McastOperFlexMediastreamClientSummary](
                ctx, s.Client(), routes.McastFlexMediastreamPath,
        )
}</span>

// ListVLANL2MGIDs retrieves VLAN Layer 2 multicast group ID operational data from the wireless controller.
// This function returns information about VLAN Layer 2 multicast groups and their configuration.
//
// Parameters:
//   - ctx: Context for request timeout and cancellation control
//
// Returns:
//   - *model.McastOperVlanL2MgidOp: VLAN Layer 2 multicast group data
//   - error: Error if the operation fails
//
// Example:
//
//        service := mcast.NewService(client)
//        data, err := service.ListVLANL2MGIDs(ctx)
//        if err != nil {
//            log.Fatal(err)
//        }
//        fmt.Printf("VLAN L2 multicast group data: %+v\n", data)
func (s Service) ListVLANL2MGIDs(ctx context.Context) (*model.McastOperVlanL2MgidOp, error) <span class="cov7" title="3">{
        return core.Get[model.McastOperVlanL2MgidOp](ctx, s.Client(), routes.McastVlanL2MgidPath)
}</span>

// GetFabricMediastreamClientSummary retrieves fabric mediastream client summary data from the wireless controller.
// This function returns information about fabric mediastream clients and their status.
//
// Parameters:
//   - ctx: Context for request timeout and cancellation control
//
// Returns:
//   - *model.McastOperFabricMediaStreamClientSummary: Fabric mediastream data
//   - error: Error if the operation fails
func (s Service) GetFabricMediastreamClientSummary(
        ctx context.Context,
) (*model.McastOperFabricMediaStreamClientSummary, error) <span class="cov7" title="3">{
        return core.Get[model.McastOperFabricMediaStreamClientSummary](
                ctx, s.Client(), routes.McastFabricMediastreamPath,
        )
}</span>

// GetMcastMgidInfo retrieves multicast MGID information from the wireless controller.
// This function returns information about multicast group IDs and their configuration.
//
// Parameters:
//   - ctx: Context for request timeout and cancellation control
//
// Returns:
//   - *model.McastOperMcastMgidInfo: Multicast MGID information
//   - error: Error if the operation fails
func (s Service) GetMcastMgidInfo(ctx context.Context) (*model.McastOperMcastMgidInfo, error) <span class="cov7" title="3">{
        return core.Get[model.McastOperMcastMgidInfo](ctx, s.Client(), routes.McastMgidInfoPath)
}</span>

// GetMulticastOperData retrieves multicast operational data from the wireless controller.
// This function returns detailed operational information about multicast operations.
//
// Parameters:
//   - ctx: Context for request timeout and cancellation control
//
// Returns:
//   - *model.McastOperMulticastOperData: Multicast operational data
//   - error: Error if the operation fails
func (s Service) GetMulticastOperData(ctx context.Context) (*model.McastOperMulticastOperData, error) <span class="cov7" title="3">{
        return core.Get[model.McastOperMulticastOperData](ctx, s.Client(), routes.McastMulticastOperDataPath)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package mdns

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/mdns"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides mDNS (Multicast DNS) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new MDNS service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="7">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves all mDNS operational data from the wireless controller.
func (s Service) GetOperational(ctx context.Context) (*model.MDNSOper, error) <span class="cov6" title="3">{
        return core.Get[model.MDNSOper](ctx, s.Client(), routes.MDNSOperPath)
}</span>

// GetGlobalStats retrieves mDNS global statistics from the wireless controller.
func (s Service) GetGlobalStats(ctx context.Context) (*model.MDNSGlobalStats, error) <span class="cov6" title="3">{
        return core.Get[model.MDNSGlobalStats](ctx, s.Client(), routes.MDNSGlobalStatsPath)
}</span>

// ListWLANStats retrieves mDNS WLAN statistics from the wireless controller.
func (s Service) ListWLANStats(ctx context.Context) (*model.MDNSWlanStats, error) <span class="cov6" title="3">{
        return core.Get[model.MDNSWlanStats](ctx, s.Client(), routes.MDNSWlanStatsPath)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package mesh

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/mesh"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides wireless mesh networking operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Mesh service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="7">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves all mesh configuration data.
func (s Service) GetConfig(ctx context.Context) (*model.MeshCfg, error) <span class="cov6" title="3">{
        return core.Get[model.MeshCfg](ctx, s.Client(), routes.MeshCfgPath)
}</span>

// GetOperational retrieves all mesh operational data.
func (s Service) GetOperational(ctx context.Context) (*model.MeshOper, error) <span class="cov6" title="3">{
        return core.Get[model.MeshOper](ctx, s.Client(), routes.MeshOperPath)
}</span>

// GetOperationalData retrieves mesh operational data including queue stats, data rate stats, security stats, and operational data.
func (s Service) GetOperationalData(ctx context.Context) (*model.MeshOper, error) <span class="cov6" title="3">{
        return core.Get[model.MeshOper](ctx, s.Client(), routes.MeshGlobalStatsPath)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package mobility

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/mobility"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides client mobility management operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Mobility service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="8">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves mobility operational data from the controller.
func (s Service) GetOperational(ctx context.Context) (*model.MobilityOper, error) <span class="cov4" title="2">{
        return core.Get[model.MobilityOper](ctx, s.Client(), routes.MobilityOperPath)
}</span>

// ListAPCache retrieves AP cache data.
func (s Service) ListAPCache(ctx context.Context) (*model.MobilityOperApCache, error) <span class="cov4" title="2">{
        return core.Get[model.MobilityOperApCache](ctx, s.Client(), routes.MobilityApCachePath)
}</span>

// ListAPPeers retrieves AP peer list data.
func (s Service) ListAPPeers(ctx context.Context) (*model.MobilityOperApPeerList, error) <span class="cov1" title="1">{
        return core.Get[model.MobilityOperApPeerList](ctx, s.Client(), routes.MobilityApPeerListPath)
}</span>

// GetMMGlobalInfo retrieves MM global information.
func (s Service) GetMMGlobalInfo(ctx context.Context) (*model.MobilityOperMmGlobalData, error) <span class="cov4" title="2">{
        return core.Get[model.MobilityOperMmGlobalData](ctx, s.Client(), routes.MobilityMmGlobalDataPath)
}</span>

// GetMMIFGlobalStats retrieves MM interface global statistics.
func (s Service) GetMMIFGlobalStats(ctx context.Context) (*model.MobilityOperMmIfGlobalStats, error) <span class="cov1" title="1">{
        return core.Get[model.MobilityOperMmIfGlobalStats](
                ctx, s.Client(), routes.MobilityMmIfGlobalStatsPath)
}</span>

// ListClients retrieves mobility client data.
func (s Service) ListClients(ctx context.Context) (*model.MobilityOperMobilityClientData, error) <span class="cov1" title="1">{
        return core.Get[model.MobilityOperMobilityClientData](
                ctx, s.Client(), routes.MobilityClientDataPath)
}</span>

// GetGlobalStats retrieves mobility global statistics.
func (s Service) GetGlobalStats(
        ctx context.Context,
) (*model.MobilityOperMobilityGlobalStats, error) <span class="cov4" title="2">{
        return core.Get[model.MobilityOperMobilityGlobalStats](
                ctx, s.Client(), routes.MobilityGlobalStatsPath,
        )
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package nmsp

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/nmsp"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides NMSP (Network Mobility Services Protocol) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new NMSP service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="3">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves NMSP operational data from the controller.
func (s Service) GetOperational(ctx context.Context) (*model.NMSPOper, error) <span class="cov1" title="1">{
        return core.Get[model.NMSPOper](ctx, s.Client(), routes.NMSPOperPath)
}</span>

// ListClientRegistrations retrieves NMSP client registration data.
func (s Service) ListClientRegistrations(ctx context.Context) (*model.NMSPClientRegistration, error) <span class="cov1" title="1">{
        return core.Get[model.NMSPClientRegistration](ctx, s.Client(), routes.NMSPClientRegistrationPath)
}</span>

// GetCMXConnectionInfo retrieves NMSP CMX connection information.
func (s Service) GetCMXConnectionInfo(ctx context.Context) (*model.NMSPCmxConnection, error) <span class="cov1" title="1">{
        return core.Get[model.NMSPCmxConnection](ctx, s.Client(), routes.NMSPCmxConnectionPath)
}</span>

// GetCMXCloudInfo retrieves NMSP CMX cloud information.
func (s Service) GetCMXCloudInfo(ctx context.Context) (*model.NMSPCmxCloudInfo, error) <span class="cov1" title="1">{
        return core.Get[model.NMSPCmxCloudInfo](ctx, s.Client(), routes.NMSPCmxCloudInfoPath)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package radio

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/radio"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides radio configuration management operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Radio service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="6">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves radio configuration data from the controller.
func (s Service) GetConfig(ctx context.Context) (*model.RadioCfg, error) <span class="cov6" title="3">{
        return core.Get[model.RadioCfg](ctx, s.Client(), routes.RadioCfgPath)
}</span>

// ListProfileConfigs retrieves radio profiles configuration data.
func (s Service) ListProfileConfigs(ctx context.Context) (*model.RadioProfiles, error) <span class="cov6" title="3">{
        return core.Get[model.RadioProfiles](ctx, s.Client(), routes.RadioCfgPath+"/radio-profiles")
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package rf

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/rf"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides RF (Radio Frequency) management operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new RF service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="18">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// RFTag returns an RF tag service instance for RF tag management operations.
func (s Service) RFTag() *RFTagService <span class="cov9" title="16">{
        return NewRFTagService(s.Client())
}</span>

// GetConfig retrieves RF configuration data including RF profiles and power settings.
func (s Service) GetConfig(ctx context.Context) (*model.RFCfg, error) <span class="cov3" title="2">{
        return core.Get[model.RFCfg](ctx, s.Client(), routes.RFCfgPath)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package rf

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/rf"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// RFTagService provides RF tag management functionality.
type RFTagService struct {
        service.BaseService
}

// NewRFTagService creates a new RF tag service.
func NewRFTagService(client *core.Client) *RFTagService <span class="cov8" title="16">{
        return &amp;RFTagService{
                BaseService: service.NewBaseService(client),
        }
}</span>

// GetConfig retrieves the RF configuration.
func (s *RFTagService) GetConfig(ctx context.Context) (*model.RFCfg, error) <span class="cov1" title="1">{
        return core.Get[model.RFCfg](ctx, s.Client(), routes.RFCfgPath)
}</span>

// GetRFTag retrieves an RF tag configuration by name.
func (s *RFTagService) GetRFTag(ctx context.Context, tagName string) (*model.RFTag, error) <span class="cov8" title="14">{
        if err := s.validateTagName(tagName); err != nil </span><span class="cov5" title="5">{
                return nil, err
        }</span>

        <span class="cov7" title="9">result, err := core.Get[model.RFCfgRFTag](ctx, s.Client(), s.buildTagURL(tagName))
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov6" title="7">if result == nil || result.RFTagList == nil || len(result.RFTagList) == 0 </span><span class="cov2" title="2">{
                return nil, nil
        }</span>

        <span class="cov5" title="5">return &amp;result.RFTagList[0], nil</span>
}

// ListRFTags retrieves all RF tag configurations.
func (s *RFTagService) ListRFTags(ctx context.Context) ([]model.RFTag, error) <span class="cov5" title="5">{
        result, err := core.Get[model.RFCfgRFTags](ctx, s.Client(), routes.RFTagsPath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="4">if result == nil </span><span class="cov0" title="0">{
                return []model.RFTag{}, nil
        }</span>

        <span class="cov4" title="4">if len(result.RFTags.RFTagList) == 0 </span><span class="cov4" title="3">{
                return []model.RFTag{}, nil
        }</span>

        <span class="cov1" title="1">return result.RFTags.RFTagList, nil</span>
}

// CreateRFTag creates a new RF tag configuration.
func (s *RFTagService) CreateRFTag(ctx context.Context, config *model.RFTag) error <span class="cov5" title="5">{
        if config == nil </span><span class="cov1" title="1">{
                return errors.New("RF tag config cannot be nil")
        }</span>
        <span class="cov4" title="4">if config.TagName == "" </span><span class="cov1" title="1">{
                return errors.New("RF tag name cannot be empty")
        }</span>

        <span class="cov4" title="3">if err := s.validateTagName(config.TagName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Build payload directly from config
        <span class="cov2" title="2">payload := s.buildPayload(config)
        return core.PostVoid(ctx, s.Client(), routes.RFTagsPath, payload)</span>
}

// DeleteRFTag deletes an RF tag configuration.
func (s *RFTagService) DeleteRFTag(ctx context.Context, tagName string) error <span class="cov4" title="3">{
        if err := s.validateTagName(tagName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov2" title="2">return core.Delete(ctx, s.Client(), s.buildTagURL(tagName))</span>
}

// SetDot11ARfProfile sets the 5GHz RF profile for an RF tag.
func (s *RFTagService) SetDot11ARfProfile(ctx context.Context, tagName, rfProfileName string) error <span class="cov4" title="3">{
        return s.updateTagField(ctx, tagName, func(payload *model.RFTag) </span><span class="cov1" title="1">{
                if payload != nil </span><span class="cov1" title="1">{
                        payload.Dot11ARfProfileName = rfProfileName
                }</span>
        })
}

// SetDot11BRfProfile sets the 2.4GHz RF profile for an RF tag.
func (s *RFTagService) SetDot11BRfProfile(ctx context.Context, tagName, rfProfileName string) error <span class="cov1" title="1">{
        return s.updateTagField(ctx, tagName, func(payload *model.RFTag) </span><span class="cov1" title="1">{
                if payload != nil </span><span class="cov1" title="1">{
                        payload.Dot11BRfProfileName = rfProfileName
                }</span>
        })
}

// SetDot116GhzRFProfile sets the 6GHz RF profile for an RF tag.
func (s *RFTagService) SetDot116GhzRFProfile(ctx context.Context, tagName, rfProfileName string) error <span class="cov1" title="1">{
        return s.updateTagField(ctx, tagName, func(payload *model.RFTag) </span><span class="cov1" title="1">{
                if payload != nil </span><span class="cov1" title="1">{
                        payload.Dot116GhzRFProfName = rfProfileName
                }</span>
        })
}

// SetDescription sets the description for an RF tag.
func (s *RFTagService) SetDescription(ctx context.Context, tagName, description string) error <span class="cov4" title="4">{
        return s.updateTagField(ctx, tagName, func(payload *model.RFTag) </span><span class="cov1" title="1">{
                if payload != nil </span><span class="cov1" title="1">{
                        payload.Description = description
                }</span>
        })
}

// updateTagField updates a specific field of an RF tag using the provided update function.
func (s *RFTagService) updateTagField(ctx context.Context, tagName string,
        updateFunc func(*model.RFTag),
) error <span class="cov7" title="9">{
        if updateFunc == nil </span><span class="cov0" title="0">{
                return errors.New("update function cannot be nil")
        }</span>

        <span class="cov7" title="9">tag, err := s.GetRFTag(ctx, tagName)
        if err != nil </span><span class="cov5" title="5">{
                return fmt.Errorf("RF tag operation failed: %w",
                        fmt.Errorf("tag retrieval failed for '%s': %w", tagName, err))
        }</span>
        <span class="cov4" title="4">if tag == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RF tag operation failed: %w",
                        fmt.Errorf("tag '%s' not found in controller configuration", tagName))
        }</span>

        <span class="cov4" title="4">updateFunc(tag)
        return s.setRFTag(ctx, tag)</span>
}

// setRFTag sets/updates an existing RF tag configuration.
func (s *RFTagService) setRFTag(ctx context.Context, config *model.RFTag) error <span class="cov4" title="4">{
        if config == nil </span><span class="cov0" title="0">{
                return errors.New("RF tag config cannot be nil")
        }</span>
        <span class="cov4" title="4">if config.TagName == "" </span><span class="cov0" title="0">{
                return errors.New("RF tag name cannot be empty")
        }</span>

        <span class="cov4" title="4">if err := s.validateTagName(config.TagName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Build payload directly from config
        <span class="cov4" title="4">payload := s.buildPayload(config)
        return core.PutVoid(ctx, s.Client(), s.buildTagURL(config.TagName), payload)</span>
}

// validateTagName validates RF tag name.
func (s *RFTagService) validateTagName(tagName string) error <span class="cov10" title="24">{
        if tagName == "" </span><span class="cov5" title="5">{
                return errors.New("RF tag name cannot be empty")
        }</span>
        <span class="cov9" title="19">if strings.TrimSpace(tagName) == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("RF tag validation failed: %w",
                        fmt.Errorf("invalid tag name format: '%s'", tagName))
        }</span>
        <span class="cov9" title="17">return nil</span>
}

// buildTagURL builds URL for specific tag operations using RESTCONF builder.
func (s *RFTagService) buildTagURL(tagName string) string <span class="cov8" title="15">{
        return fmt.Sprintf("%s/rf-tag=%s", routes.RFTagsPath, tagName)
}</span>

// buildPayload builds the payload for POST/PUT operations.
func (s *RFTagService) buildPayload(config *model.RFTag) map[string]any <span class="cov6" title="6">{
        return map[string]any{
                "Cisco-IOS-XE-wireless-rf-cfg:rf-tag": config,
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package rfid

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/rfid"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/validation"
)

// Service provides RFID (Radio Frequency Identification) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new RFID service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="6">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves RFID configuration data.
func (s Service) GetConfig(ctx context.Context) (*model.RFIDCfg, error) <span class="cov4" title="2">{
        return core.Get[model.RFIDCfg](ctx, s.Client(), routes.RFIDCfgPath)
}</span>

// GetConfigSettings retrieves the RFID configuration settings.
func (s Service) GetConfigSettings(ctx context.Context) (*model.RFIDConfig, error) <span class="cov1" title="1">{
        url := routes.RFIDCfgPath + "/rfid-config"
        return core.Get[model.RFIDConfig](ctx, s.Client(), url)
}</span>

// GetGlobalInfo retrieves RFID global information.
func (s Service) GetGlobalInfo(ctx context.Context) (*model.RFIDGlobalOper, error) <span class="cov1" title="1">{
        return core.Get[model.RFIDGlobalOper](ctx, s.Client(), routes.RFIDGlobalOperPath)
}</span>

// GetGlobalDetailByMAC retrieves specific RFID data detail by MAC address.
func (s Service) GetGlobalDetailByMAC(
        ctx context.Context,
        macAddr string,
) (*model.RFIDEmltdData, error) <span class="cov4" title="2">{
        if err := validation.ValidateMACAddress(macAddr); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.RFIDDataDetailQueryPath, macAddr)
        return core.Get[model.RFIDEmltdData](ctx, s.Client(), url)</span>
}

// GetRadioInfo retrieves RFID radio information by radio key combination.
func (s Service) GetRadioInfo(
        ctx context.Context,
        macAddr, apMACAddr string,
        slot int,
) (*model.RFIDRadioData, error) <span class="cov6" title="3">{
        if err := validation.ValidateMACAddress(macAddr); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if err := validation.ValidateMACAddress(apMACAddr); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryCompositeURL(
                routes.RFIDRadioDataPath,
                macAddr,
                apMACAddr,
                slot,
        )
        return core.Get[model.RFIDRadioData](ctx, s.Client(), url)</span>
}

// GetOperational retrieves RFID operational data.
func (s Service) GetOperational(ctx context.Context) (*model.RFIDOper, error) <span class="cov4" title="2">{
        return core.Get[model.RFIDOper](ctx, s.Client(), routes.RFIDOperPath)
}</span>

// GetDetailByMAC retrieves specific RFID data based on MAC address.
func (s Service) GetDetailByMAC(ctx context.Context, macAddr string) (*model.RFIDData, error) <span class="cov4" title="2">{
        if err := validation.ValidateMACAddress(macAddr); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.RFIDDataQueryPath, macAddr)
        return core.Get[model.RFIDData](ctx, s.Client(), url)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package rogue

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/rogue"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides rogue detection and mitigation operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Rogue service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="8">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves rogue detection operational data from the controller.
func (s Service) GetOperational(ctx context.Context) (*model.RogueOper, error) <span class="cov4" title="2">{
        return core.Get[model.RogueOper](ctx, s.Client(), routes.RogueOperPath)
}</span>

// ListRogues retrieves rogue client data.
func (s Service) ListRogues(ctx context.Context) (*model.RogueData, error) <span class="cov5" title="3">{
        return core.Get[model.RogueData](ctx, s.Client(), routes.RogueDataPath)
}</span>

// GetRogueByMAC retrieves rogue data filtered by rogue address.
func (s Service) GetRogueByMAC(ctx context.Context, mac string) (*model.RogueData, error) <span class="cov7" title="4">{
        if mac == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov5" title="3">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.RogueDataPath, mac)
        return core.Get[model.RogueData](ctx, s.Client(), url)</span>
}

// ListRogueClients retrieves rogue client data.
func (s Service) ListRogueClients(ctx context.Context) (*model.RogueClientData, error) <span class="cov5" title="3">{
        return core.Get[model.RogueClientData](ctx, s.Client(), routes.RogueClientDataPath)
}</span>

// GetRogueClientByMAC retrieves rogue data filtered by rogue address.
func (s Service) GetRogueClientByMAC(ctx context.Context, mac string) (*model.RogueClientData, error) <span class="cov7" title="4">{
        if mac == "" </span><span class="cov1" title="1">{
                return nil, core.ErrInvalidConfiguration
        }</span>

        <span class="cov5" title="3">url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.RogueClientDataPath, mac)
        return core.Get[model.RogueClientData](ctx, s.Client(), url)</span>
}

// GetStats retrieves rogue statistics.
func (s Service) GetStats(ctx context.Context) (*model.RogueStatsData, error) <span class="cov7" title="4">{
        return core.Get[model.RogueStatsData](ctx, s.Client(), routes.RogueStatsPath)
}</span>

// Alias methods for integration test compatibility

// GetOperClientData is an alias for ListRogueClients.
func (s Service) GetOperClientData(ctx context.Context) (*model.RogueClientData, error) <span class="cov1" title="1">{
        return s.ListRogueClients(ctx)
}</span>

// GetOperData is an alias for ListRogues.
func (s Service) GetOperData(ctx context.Context) (*model.RogueData, error) <span class="cov1" title="1">{
        return s.ListRogues(ctx)
}</span>

// GetOperStats is an alias for GetStats.
func (s Service) GetOperStats(ctx context.Context) (*model.RogueStatsData, error) <span class="cov1" title="1">{
        return s.GetStats(ctx)
}</span>

// GetRLDPStats retrieves RLDP (Rogue Location Discovery Protocol) statistics.
func (s Service) GetRLDPStats(ctx context.Context) (*model.RogueStatsData, error) <span class="cov1" title="1">{
        // For now, return the same as rogue stats since RLDP is part of rogue detection
        return s.GetStats(ctx)
}</span>

// GetOperByRogueAddress is an alias for GetRogueByMAC.
func (s Service) GetOperByRogueAddress(ctx context.Context, mac string) (*model.RogueData, error) <span class="cov1" title="1">{
        return s.GetRogueByMAC(ctx, mac)
}</span>

// GetOperByRogueClientAddress is an alias for GetRogueClientByMAC.
func (s Service) GetOperByRogueClientAddress(ctx context.Context, mac string) (*model.RogueClientData, error) <span class="cov1" title="1">{
        return s.GetRogueClientByMAC(ctx, mac)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package rrm

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/rrm"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides RRM (Radio Resource Management) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new RRM service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="5">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves complete RRM configuration data.
func (s Service) GetConfig(ctx context.Context) (*model.RRMCfg, error) <span class="cov7" title="3">{
        return core.Get[model.RRMCfg](ctx, s.Client(), routes.RRMCfgPath)
}</span>

// GetOperational retrieves RRM operational data.
func (s Service) GetOperational(ctx context.Context) (*model.RRMOper, error) <span class="cov7" title="3">{
        return core.Get[model.RRMOper](ctx, s.Client(), routes.RRMOperPath)
}</span>

// GetGlobalOperational retrieves RRM global operational information.
func (s Service) GetGlobalOperational(ctx context.Context) (*model.RRMGlobalOper, error) <span class="cov7" title="3">{
        return core.Get[model.RRMGlobalOper](ctx, s.Client(), routes.RRMGlobalOperPath)
}</span>

// GetEmulationOperational retrieves RRM emulation operational information.
func (s Service) GetEmulationOperational(ctx context.Context) (*model.RRMEmulOper, error) <span class="cov7" title="3">{
        return core.Get[model.RRMEmulOper](ctx, s.Client(), routes.RRMEmulOperPath)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package site

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/site"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides site configuration operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Site service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="18">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// SiteTag returns a site tag service instance for site tag management operations.
func (s Service) SiteTag() *SiteTagService <span class="cov9" title="14">{
        return NewSiteTagService(s.Client())
}</span>

// GetConfig retrieves site configuration data including AP configuration profiles and site tag configurations.
func (s Service) GetConfig(ctx context.Context) (*model.SiteCfg, error) <span class="cov3" title="2">{
        return core.Get[model.SiteCfg](ctx, s.Client(), routes.SiteCfgPath)
}</span>

// ListAPProfileConfigs retrieves all AP configuration profiles from the site configuration.
func (s Service) ListAPProfileConfigs(ctx context.Context) (*model.SiteCfgApCfgProfiles, error) <span class="cov3" title="2">{
        return core.Get[model.SiteCfgApCfgProfiles](ctx, s.Client(), routes.APProfilesPath)
}</span>

// ListSiteTagConfigs retrieves all site tag configurations from the site configuration.
func (s Service) ListSiteTagConfigs(ctx context.Context) (*model.SiteCfgSiteTagConfigs, error) <span class="cov3" title="2">{
        return core.Get[model.SiteCfgSiteTagConfigs](ctx, s.Client(), routes.SiteTagConfigsPath)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package site

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/site"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// SiteTagService provides site tag management operations.
type SiteTagService struct {
        service.BaseService
}

// NewSiteTagService creates a new site tag service.
func NewSiteTagService(client *core.Client) *SiteTagService <span class="cov7" title="14">{
        return &amp;SiteTagService{
                BaseService: service.NewBaseService(client),
        }
}</span>

// GetSiteTag retrieves a specific site tag configuration.
func (s *SiteTagService) GetSiteTag(ctx context.Context, tagName string) (*model.SiteListEntry, error) <span class="cov8" title="23">{
        if err := s.validateTagName(tagName); err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov8" title="21">result, err := core.Get[model.SiteCfgSiteTagConfig](ctx, s.Client(), s.buildTagURL(tagName))
        if err != nil </span><span class="cov5" title="5">{
                return nil, err
        }</span>
        <span class="cov7" title="16">if result == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov7" title="16">if len(result.SiteListEntry) == 0 </span><span class="cov5" title="5">{
                return nil, nil
        }</span>

        <span class="cov7" title="11">return &amp;result.SiteListEntry[0], nil</span>
}

// ListSiteTags retrieves all site tag configurations.
func (s *SiteTagService) ListSiteTags(ctx context.Context) ([]model.SiteListEntry, error) <span class="cov5" title="6">{
        type siteTagsResponse struct {
                SiteTagConfigs model.SiteTagConfigs `json:"Cisco-IOS-XE-wireless-site-cfg:site-tag-configs"`
        }

        result, err := core.Get[siteTagsResponse](ctx, s.Client(), routes.SiteTagConfigsPath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="5">if result == nil </span><span class="cov0" title="0">{
                return []model.SiteListEntry{}, nil
        }</span>
        <span class="cov5" title="5">if len(result.SiteTagConfigs.SiteTagConfig) == 0 </span><span class="cov3" title="3">{
                return []model.SiteListEntry{}, nil
        }</span>

        <span class="cov2" title="2">return result.SiteTagConfigs.SiteTagConfig, nil</span>
}

// CreateSiteTag creates a new site tag configuration.
func (s *SiteTagService) CreateSiteTag(ctx context.Context, config *model.SiteListEntry) error <span class="cov4" title="4">{
        if config == nil </span><span class="cov1" title="1">{
                return errors.New("config cannot be nil")
        }</span>
        <span class="cov3" title="3">if config.SiteTagName == "" </span><span class="cov1" title="1">{
                return errors.New("site tag name cannot be empty")
        }</span>
        <span class="cov2" title="2">if err := s.validateTagName(config.SiteTagName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert service payload model to internal model
        <span class="cov2" title="2">payload := s.buildPayload(*config)
        return core.PostVoid(ctx, s.Client(), routes.SiteTagConfigsPath, payload)</span>
}

// SetAPJoinProfile sets the AP join profile for a site tag.
func (s *SiteTagService) SetAPJoinProfile(ctx context.Context, siteTagName, apJoinProfile string) error <span class="cov4" title="4">{
        config, err := s.GetSiteTag(ctx, siteTagName)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("site tag operation failed: %w",
                        fmt.Errorf("tag retrieval failed for '%s': %w", siteTagName, err))
        }</span>
        <span class="cov3" title="3">if config == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("site tag operation failed: %w",
                        fmt.Errorf("tag '%s' not found in controller configuration", siteTagName))
        }</span>

        // Update AP join profile
        <span class="cov2" title="2">config.ApJoinProfile = &amp;apJoinProfile
        return s.setSiteTag(ctx, config)</span>
}

// SetFlexProfile sets the flex profile for a site tag.
func (s *SiteTagService) SetFlexProfile(ctx context.Context, siteTagName, flexProfile string) error <span class="cov4" title="4">{
        config, err := s.GetSiteTag(ctx, siteTagName)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("site tag operation failed: %w",
                        fmt.Errorf("tag retrieval failed for '%s': %w", siteTagName, err))
        }</span>

        <span class="cov3" title="3">if config == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("site tag operation failed: %w",
                        fmt.Errorf("tag '%s' not found in controller configuration", siteTagName))
        }</span>

        // Update flex profile
        <span class="cov2" title="2">config.FlexProfile = &amp;flexProfile
        // Explicitly set to false for flex-profile compatibility
        isLocalSite := false
        config.IsLocalSite = &amp;isLocalSite
        return s.setSiteTag(ctx, config)</span>
}

// SetLocalSite sets the local site mode for a site tag.
func (s *SiteTagService) SetLocalSite(ctx context.Context, siteTagName string, enabled bool) error <span class="cov4" title="4">{
        config, err := s.GetSiteTag(ctx, siteTagName)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("site tag operation failed: %w",
                        fmt.Errorf("tag retrieval failed for '%s': %w", siteTagName, err))
        }</span>

        <span class="cov3" title="3">if config == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("site tag operation failed: %w",
                        fmt.Errorf("tag '%s' not found in controller configuration", siteTagName))
        }</span>

        // Update local site
        <span class="cov2" title="2">config.IsLocalSite = &amp;enabled
        return s.setSiteTag(ctx, config)</span>
}

// SetDescription sets the description for a site tag.
func (s *SiteTagService) SetDescription(ctx context.Context, siteTagName, description string) error <span class="cov4" title="4">{
        config, err := s.GetSiteTag(ctx, siteTagName)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("site tag operation failed: %w",
                        fmt.Errorf("tag retrieval failed for '%s': %w", siteTagName, err))
        }</span>
        <span class="cov3" title="3">if config == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("site tag operation failed: %w",
                        fmt.Errorf("tag '%s' not found in controller configuration", siteTagName))
        }</span>

        // Update description
        <span class="cov2" title="2">config.Description = &amp;description
        return s.setSiteTag(ctx, config)</span>
}

// DeleteSiteTag deletes a site tag configuration.
func (s *SiteTagService) DeleteSiteTag(ctx context.Context, siteTagName string) error <span class="cov3" title="3">{
        if err := s.validateTagName(siteTagName); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>
        <span class="cov1" title="1">return core.Delete(ctx, s.Client(), s.buildTagURL(siteTagName))</span>
}

// setSiteTag sets/updates an existing site tag configuration.
func (s *SiteTagService) setSiteTag(ctx context.Context, config *model.SiteListEntry) error <span class="cov6" title="8">{
        if config == nil </span><span class="cov0" title="0">{
                return errors.New("config cannot be nil")
        }</span>
        <span class="cov6" title="8">if config.SiteTagName == "" </span><span class="cov0" title="0">{
                return errors.New("site tag name cannot be empty")
        }</span>
        <span class="cov6" title="8">if err := s.validateTagName(config.SiteTagName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert service payload model to internal model
        <span class="cov6" title="8">payload := s.buildPayload(*config)
        return core.PatchVoid(ctx, s.Client(), s.buildTagURL(config.SiteTagName), payload)</span>
}

// validateTagName validates site tag name.
func (s *SiteTagService) validateTagName(tagName string) error <span class="cov10" title="36">{
        if tagName == "" </span><span class="cov2" title="2">{
                return errors.New("site tag name cannot be empty")
        }</span>
        <span class="cov9" title="34">if strings.TrimSpace(tagName) == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("site tag validation failed: %w",
                        fmt.Errorf("invalid tag name format: '%s'", tagName))
        }</span>
        <span class="cov9" title="32">return nil</span>
}

// buildTagURL builds URL for specific tag operations using RESTCONF builder.
func (s *SiteTagService) buildTagURL(tagName string) string <span class="cov9" title="30">{
        return s.Client().RESTCONFBuilder().BuildQueryURL(routes.SiteTagConfigQueryPath, tagName)
}</span>

// buildPayload builds a payload for tag operations using the request model.
func (s *SiteTagService) buildPayload(config model.SiteListEntry) model.SiteTagConfigsPayload <span class="cov6" title="10">{
        return model.SiteTagConfigsPayload{
                SiteListEntry: config,
        }
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package spaces

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/spaces"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides Cisco Spaces integration operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new Spaces service instance with the provided client.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func NewService(client *core.Client) Service <span class="cov10" title="4">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetOperational retrieves all Cisco Spaces operational data from the controller.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func (s Service) GetOperational(ctx context.Context) (*model.CiscoSpacesOper, error) <span class="cov5" title="2">{
        return core.Get[model.CiscoSpacesOper](ctx, s.Client(), routes.SpacesOperPath)
}</span>

// GetConnectionDetails retrieves detailed connection information for Cisco Spaces integration.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func (s Service) GetConnectionDetails(ctx context.Context) (*model.SpacesConnectionDetail, error) <span class="cov5" title="2">{
        return core.Get[model.SpacesConnectionDetail](ctx, s.Client(), routes.SpacesConnectionDetailPath)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package urwb

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/urwb"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides access to URWB (Ultra Reliable Wireless Backhaul) operations.
type Service struct {
        service.BaseService
}

// NewService creates a new URWB service instance with the provided client.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func NewService(client *core.Client) Service <span class="cov10" title="5">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves the complete URWB configuration from the controller.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func (s Service) GetConfig(ctx context.Context) (*model.URWBCfg, error) <span class="cov4" title="2">{
        return core.Get[model.URWBCfg](ctx, s.Client(), routes.URWBCfgPath)
}</span>

// GetURWBNetOperational retrieves URWB network operational data from the controller.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func (s Service) GetURWBNetOperational(ctx context.Context) (*model.URWBnetOper, error) <span class="cov1" title="1">{
        return core.Get[model.URWBnetOper](ctx, s.Client(), routes.URWBNetOperPath)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package wat

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/wat"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides Wireless Application Templates (WAT) operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new WAT service instance with the provided client.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func NewService(client *core.Client) Service <span class="cov10" title="5">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// GetConfig retrieves the complete WAT configuration from the controller.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func (s Service) GetConfig(ctx context.Context) (*model.WATCfg, error) <span class="cov7" title="3">{
        return core.Get[model.WATCfg](ctx, s.Client(), routes.WATCfgPath)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package wlan provides WLAN domain services for Cisco IOS-XE Wireless Network Controller API.
package wlan

import (
        "context"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/wlan"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// Service provides WLAN operations for Cisco IOS-XE Wireless LAN Controller.
type Service struct {
        service.BaseService
}

// NewService creates a new WLAN service instance with the provided client.
func NewService(client *core.Client) Service <span class="cov10" title="21">{
        return Service{BaseService: service.NewBaseService(client)}
}</span>

// PolicyTag returns a PolicyTagService for policy tag operations.
func (s Service) PolicyTag() *PolicyTagService <span class="cov9" title="18">{
        return NewPolicyTagService(s.Client())
}</span>

// ListProfileConfigs retrieves WLAN configuration entries.
func (s Service) ListProfileConfigs(ctx context.Context) (*model.WlanCfgEntries, error) <span class="cov3" title="2">{
        return core.Get[model.WlanCfgEntries](ctx, s.Client(), routes.WLANWlanCfgEntriesPath)
}</span>

// GetProfileConfig retrieves a specific WLAN configuration entry by profile name.
func (s Service) GetProfileConfig(ctx context.Context, profileName string) (*model.WlanCfgEntry, error) <span class="cov3" title="2">{
        url := s.Client().RESTCONFBuilder().BuildQueryURL(routes.WLANWlanCfgEntryPath, profileName)
        return core.Get[model.WlanCfgEntry](ctx, s.Client(), url)
}</span>

// ListPolicies retrieves WLAN policies.
func (s Service) ListPolicies(ctx context.Context) (*model.WlanPolicies, error) <span class="cov3" title="2">{
        return core.Get[model.WlanPolicies](ctx, s.Client(), routes.WLANWlanPoliciesPath)
}</span>

// ListPolicyListEntries retrieves all policy list entries.
func (s Service) ListPolicyListEntries(ctx context.Context) (*model.PolicyListEntries, error) <span class="cov3" title="2">{
        return core.Get[model.PolicyListEntries](ctx, s.Client(), routes.WLANPolicyListEntriesPath)
}</span>

// ListWirelessAAAPolicyConfigs retrieves wireless AAA policy configurations.
func (s Service) ListWirelessAAAPolicyConfigs(ctx context.Context) (*model.WirelessAaaPolicyConfigs, error) <span class="cov3" title="2">{
        return core.Get[model.WirelessAaaPolicyConfigs](ctx, s.Client(), routes.WLANWirelessAaaPolicyConfigsPath)
}</span>

// GetConfig retrieves WLAN configuration data from the controller.
func (s Service) GetConfig(ctx context.Context) (*model.WlanCfg, error) <span class="cov3" title="2">{
        return core.Get[model.WlanCfg](ctx, s.Client(), routes.WLANCfgPath)
}</span>

// GetOperational retrieves WLAN operational data from the controller.
func (s Service) GetOperational(ctx context.Context) (*model.WlanGlobalOper, error) <span class="cov3" title="2">{
        return core.Get[model.WlanGlobalOper](ctx, s.Client(), routes.WLANGlobalOperPath)
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package wlan

import (
        "context"
        "errors"
        "fmt"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        model "github.com/umatare5/cisco-ios-xe-wireless-go/internal/model/wlan"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/restconf/routes"
        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/service"
)

// PolicyTagService provides Policy Tag management operations.
type PolicyTagService struct {
        service.BaseService
}

// NewPolicyTagService creates a new PolicyTagService instance.
func NewPolicyTagService(c *core.Client) *PolicyTagService <span class="cov9" title="18">{
        return &amp;PolicyTagService{
                BaseService: service.NewBaseService(c),
        }
}</span>

// GetPolicyTag retrieves a specific policy tag configuration.
func (s *PolicyTagService) GetPolicyTag(ctx context.Context, tagName string) (*model.PolicyListEntry, error) <span class="cov8" title="13">{
        if err := s.validateTagName(tagName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get all policy tags and find the specific one
        <span class="cov8" title="13">allTags, err := s.ListPolicyTags(ctx)
        if err != nil </span><span class="cov5" title="5">{
                return nil, err
        }</span>

        // Find the tag with the matching name
        <span class="cov6" title="8">for _, tag := range allTags </span><span class="cov4" title="4">{
                if tag.TagName == tagName </span><span class="cov4" title="3">{
                        return &amp;tag, nil
                }</span>
        }

        // Tag not found
        <span class="cov5" title="5">return nil, nil</span>
}

// ListPolicyTags retrieves all policy tag configurations.
func (s *PolicyTagService) ListPolicyTags(ctx context.Context) ([]model.PolicyListEntry, error) <span class="cov9" title="21">{
        result, err := core.Get[model.WlanCfgPolicyListEntries](ctx, s.Client(), routes.WLANPolicyListEntriesPath)
        if err != nil </span><span class="cov6" title="6">{
                return nil, err
        }</span>

        <span class="cov8" title="15">if result == nil </span><span class="cov0" title="0">{
                return []model.PolicyListEntry{}, nil
        }</span>

        <span class="cov8" title="15">if result.PolicyListEntries == nil </span><span class="cov4" title="3">{
                return []model.PolicyListEntry{}, nil
        }</span>

        <span class="cov8" title="12">if result.PolicyListEntries.PolicyListEntry == nil </span><span class="cov1" title="1">{
                return []model.PolicyListEntry{}, nil
        }</span>

        <span class="cov7" title="11">return result.PolicyListEntries.PolicyListEntry, nil</span>
}

// CreatePolicyTag creates a new policy tag configuration.
func (s *PolicyTagService) CreatePolicyTag(ctx context.Context, config *model.PolicyListEntry) error <span class="cov4" title="4">{
        if config == nil </span><span class="cov1" title="1">{
                return errors.New("config cannot be nil")
        }</span>
        <span class="cov4" title="3">if config.TagName == "" </span><span class="cov1" title="1">{
                return errors.New("policy tag name cannot be empty")
        }</span>

        <span class="cov2" title="2">if err := s.validateTagName(config.TagName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Use the model directly without conversion
        <span class="cov1" title="1">payload := s.buildPayload(*config)
        return core.PostVoid(ctx, s.Client(), routes.WLANPolicyListEntriesPath, payload)</span>
}

// SetPolicyTag configures a policy tag on the wireless controller using PUT operation.
func (s *PolicyTagService) SetPolicyTag(ctx context.Context, config *model.PolicyListEntry) error <span class="cov6" title="6">{
        if config == nil </span><span class="cov1" title="1">{
                return errors.New("config cannot be nil")
        }</span>
        <span class="cov5" title="5">if config.TagName == "" </span><span class="cov1" title="1">{
                return errors.New("policy tag name cannot be empty")
        }</span>

        <span class="cov4" title="4">if err := s.validateTagName(config.TagName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Use the model directly without conversion
        <span class="cov4" title="3">payload := s.buildPayload(*config)
        return core.PatchVoid(ctx, s.Client(), s.buildTagURL(config.TagName), payload)</span>
}

// SetPolicyProfile sets the policy profile for a specific WLAN in a policy tag.
func (s *PolicyTagService) SetPolicyProfile(
        ctx context.Context,
        tagName, wlanProfileName, policyProfileName string,
) error <span class="cov5" title="5">{
        // Get existing policy tag
        config, err := s.GetPolicyTag(ctx, tagName)
        if err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("policy tag operation failed: %w",
                        fmt.Errorf("tag retrieval failed for '%s': %w", tagName, err))
        }</span>

        <span class="cov4" title="3">if config == nil </span><span class="cov2" title="2">{
                return fmt.Errorf("policy tag operation failed: %w",
                        fmt.Errorf("tag '%s' not found in controller configuration", tagName))
        }</span>

        // Initialize WLANPolicies if nil
        <span class="cov1" title="1">if config.WLANPolicies == nil </span><span class="cov0" title="0">{
                config.WLANPolicies = &amp;model.WLANPolicies{
                        WLANPolicy: []model.WLANPolicyMap{},
                }
        }</span>

        // Find existing WLAN policy or add new one
        <span class="cov1" title="1">found := false
        for i := range config.WLANPolicies.WLANPolicy </span><span class="cov1" title="1">{
                if config.WLANPolicies.WLANPolicy[i].WLANProfileName == wlanProfileName </span><span class="cov0" title="0">{
                        config.WLANPolicies.WLANPolicy[i].PolicyProfileName = policyProfileName
                        found = true
                        break</span>
                }
        }

        <span class="cov1" title="1">if !found </span><span class="cov1" title="1">{
                config.WLANPolicies.WLANPolicy = append(config.WLANPolicies.WLANPolicy, model.WLANPolicyMap{
                        WLANProfileName:   wlanProfileName,
                        PolicyProfileName: policyProfileName,
                })
        }</span>

        <span class="cov1" title="1">return s.SetPolicyTag(ctx, config)</span>
}

// SetDescription sets the description for a policy tag.
func (s *PolicyTagService) SetDescription(ctx context.Context, tagName, description string) error <span class="cov4" title="3">{
        config, err := s.GetPolicyTag(ctx, tagName)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("policy tag operation failed: %w",
                        fmt.Errorf("tag retrieval failed for '%s': %w", tagName, err))
        }</span>

        <span class="cov2" title="2">if config == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("policy tag operation failed: %w",
                        fmt.Errorf("tag '%s' not found in controller configuration", tagName))
        }</span>

        // Update description
        <span class="cov1" title="1">config.Description = description
        return s.SetPolicyTag(ctx, config)</span>
}

// DeletePolicyTag deletes a policy tag configuration.
func (s *PolicyTagService) DeletePolicyTag(ctx context.Context, tagName string) error <span class="cov5" title="5">{
        if err := s.validateTagName(tagName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov4" title="4">return core.Delete(ctx, s.Client(), s.buildTagURL(tagName))</span>
}

// validateTagName validates policy tag name.
func (s *PolicyTagService) validateTagName(tagName string) error <span class="cov10" title="24">{
        if tagName == "" </span><span class="cov1" title="1">{
                return errors.New("policy tag name cannot be empty")
        }</span>
        <span class="cov9" title="23">if len(tagName) &gt; 32 </span><span class="cov2" title="2">{
                return fmt.Errorf("policy tag validation failed: %w",
                        fmt.Errorf("tag name length validation failed: name too long (max 32 characters): '%s'", tagName))
        }</span>
        <span class="cov9" title="21">return nil</span>
}

// buildTagURL builds URL for specific tag operations using RESTCONF builder.
func (s *PolicyTagService) buildTagURL(tagName string) string <span class="cov6" title="7">{
        return s.Client().RESTCONFBuilder().BuildQueryURL(
                routes.WLANPolicyListEntryQueryPath,
                tagName,
        )
}</span>

// buildPayload builds a payload for tag operations directly.
func (s *PolicyTagService) buildPayload(config model.PolicyListEntry) map[string]interface{} <span class="cov4" title="4">{
        return map[string]interface{}{
                "Cisco-IOS-XE-wireless-wlan-cfg:policy-list-entry": config,
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package wnc provides a unified client for the Cisco Wireless Network Controller API.
package wnc

import (
        "log/slog"
        "time"

        "github.com/umatare5/cisco-ios-xe-wireless-go/internal/core"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/afc"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/ap"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/apf"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/awips"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/ble"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/client"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/controller"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/cts"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/dot11"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/dot15"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/fabric"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/flex"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/general"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/geolocation"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/hyperlocation"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/lisp"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/location"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/mcast"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/mdns"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/mesh"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/mobility"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/nmsp"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/radio"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/rf"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/rfid"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/rogue"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/rrm"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/site"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/spaces"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/urwb"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/wat"
        "github.com/umatare5/cisco-ios-xe-wireless-go/service/wlan"
)

// DefaultTimeout is the default request timeout (re-export of core.DefaultTimeout).
const DefaultTimeout = core.DefaultTimeout

// Error sentinels re-exported for consumer side error handling with errors.Is.
var (
        ErrAuthenticationFailed = core.ErrAuthenticationFailed
        ErrAccessForbidden      = core.ErrAccessForbidden
        ErrResourceNotFound     = core.ErrResourceNotFound
        ErrInvalidConfiguration = core.ErrInvalidConfiguration
        ErrRequestTimeout       = core.ErrRequestTimeout
)

// APIError is returned for HTTP error responses (type alias to preserve instanceof semantics with errors.As).
type APIError = core.APIError

// Client represents the unified WNC API client with access to all domain services.
// This provides a single-import approach to accessing all wireless controller functionality.
type Client struct {
        core *core.Client // Core client that handles HTTP communication
}

// NewClient creates a new unified WNC client with the specified host, token, and options.
// This is the main entry point for all wireless controller operations.
func NewClient(host, token string, opts ...Option) (*Client, error) <span class="cov10" title="6">{
        coreClient, err := core.New(host, token, opts...)
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>
        <span class="cov7" title="4">return &amp;Client{core: coreClient}, nil</span>
}

// Option is a functional option for configuring the unified client (re-export of internal core.Option).
// This allows end users to supply options without importing the internal/core package.
type Option = core.Option

// WithTimeout sets the request timeout (re-export wrapper).
func WithTimeout(d time.Duration) Option <span class="cov1" title="1">{ return core.WithTimeout(d) }</span>

// WithInsecureSkipVerify controls TLS certificate verification (lab/testing only).
func WithInsecureSkipVerify(skip bool) Option <span class="cov1" title="1">{ return core.WithInsecureSkipVerify(skip) }</span>

// WithLogger sets a custom slog.Logger.
func WithLogger(l *slog.Logger) Option <span class="cov1" title="1">{ return core.WithLogger(l) }</span>

// WithUserAgent sets a custom User-Agent header value.
func WithUserAgent(ua string) Option <span class="cov1" title="1">{ return core.WithUserAgent(ua) }</span>

// Core returns the underlying core.Client for advanced use cases.
// This should typically not be needed for normal usage.
func (c *Client) Core() *core.Client <span class="cov1" title="1">{
        return c.core
}</span>

// Domain service accessors - each returns a service instance for the respective domain

// AFC returns the Automated Frequency Coordination service.
func (c *Client) AFC() afc.Service <span class="cov1" title="1">{
        return afc.NewService(c.core)
}</span>

// AP returns the Access Point service.
func (c *Client) AP() ap.Service <span class="cov1" title="1">{
        return ap.NewService(c.core)
}</span>

// APF returns the Application Policy Framework service.
func (c *Client) APF() apf.Service <span class="cov1" title="1">{
        return apf.NewService(c.core)
}</span>

// AWIPS returns the Advanced Weather Interactive Processing System service.
func (c *Client) AWIPS() awips.Service <span class="cov1" title="1">{
        return awips.NewService(c.core)
}</span>

// BLE returns the Bluetooth Low Energy service.
func (c *Client) BLE() ble.Service <span class="cov1" title="1">{
        return ble.NewService(c.core)
}</span>

// Client returns the wireless client service.
func (c *Client) Client() client.Service <span class="cov1" title="1">{
        return client.NewService(c.core)
}</span>

// Controller returns the controller management service.
func (c *Client) Controller() controller.Service <span class="cov1" title="1">{
        return controller.NewService(c.core)
}</span>

// CTS returns the Cisco TrustSec service.
func (c *Client) CTS() cts.Service <span class="cov1" title="1">{
        return cts.NewService(c.core)
}</span>

// Dot11 returns the 802.11 wireless standard service.
func (c *Client) Dot11() dot11.Service <span class="cov1" title="1">{
        return dot11.NewService(c.core)
}</span>

// Dot15 returns the 802.15 standard service.
func (c *Client) Dot15() dot15.Service <span class="cov1" title="1">{
        return dot15.NewService(c.core)
}</span>

// Fabric returns the Fabric service.
func (c *Client) Fabric() fabric.Service <span class="cov1" title="1">{
        return fabric.NewService(c.core)
}</span>

// Flex returns the FlexConnect service.
func (c *Client) Flex() flex.Service <span class="cov1" title="1">{
        return flex.NewService(c.core)
}</span>

// General returns the general controller service.
func (c *Client) General() general.Service <span class="cov1" title="1">{
        return general.NewService(c.core)
}</span>

// Geolocation returns the geolocation service.
func (c *Client) Geolocation() geolocation.Service <span class="cov1" title="1">{
        return geolocation.NewService(c.core)
}</span>

// Hyperlocation returns the hyperlocation service.
func (c *Client) Hyperlocation() hyperlocation.Service <span class="cov1" title="1">{
        return hyperlocation.NewService(c.core)
}</span>

// LISP returns the LISP service.
func (c *Client) LISP() lisp.Service <span class="cov1" title="1">{
        return lisp.NewService(c.core)
}</span>

// Location returns the location services service.
func (c *Client) Location() location.Service <span class="cov1" title="1">{
        return location.NewService(c.core)
}</span>

// Mcast returns the multicast service.
func (c *Client) Mcast() mcast.Service <span class="cov1" title="1">{
        return mcast.NewService(c.core)
}</span>

// MDNS returns the multicast DNS service.
func (c *Client) MDNS() mdns.Service <span class="cov1" title="1">{
        return mdns.NewService(c.core)
}</span>

// Mesh returns the mesh networking service.
func (c *Client) Mesh() mesh.Service <span class="cov1" title="1">{
        return mesh.NewService(c.core)
}</span>

// Mobility returns the mobility management service.
func (c *Client) Mobility() mobility.Service <span class="cov1" title="1">{
        return mobility.NewService(c.core)
}</span>

// NMSP returns the Network Mobility Services Protocol service.
func (c *Client) NMSP() nmsp.Service <span class="cov1" title="1">{
        return nmsp.NewService(c.core)
}</span>

// Radio returns the radio management service.
func (c *Client) Radio() radio.Service <span class="cov1" title="1">{
        return radio.NewService(c.core)
}</span>

// RF returns the Radio Frequency management service.
func (c *Client) RF() rf.Service <span class="cov1" title="1">{
        return rf.NewService(c.core)
}</span>

// RFID returns the RFID service.
func (c *Client) RFID() rfid.Service <span class="cov1" title="1">{
        return rfid.NewService(c.core)
}</span>

// Rogue returns the rogue access point detection service.
func (c *Client) Rogue() rogue.Service <span class="cov1" title="1">{
        return rogue.NewService(c.core)
}</span>

// RRM returns the Radio Resource Management service.
func (c *Client) RRM() rrm.Service <span class="cov1" title="1">{
        return rrm.NewService(c.core)
}</span>

// Site returns the site management service.
func (c *Client) Site() site.Service <span class="cov1" title="1">{
        return site.NewService(c.core)
}</span>

// Spaces returns the Cisco Spaces integration service.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func (c *Client) Spaces() spaces.Service <span class="cov1" title="1">{
        return spaces.NewService(c.core)
}</span>

// URWB returns the Ultra Reliable Wireless Backhaul service.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func (c *Client) URWB() urwb.Service <span class="cov1" title="1">{
        return urwb.NewService(c.core)
}</span>

// WAT returns the Wireless Application Templates service.
// EXPERIMENTAL: Requires IOS-XE 17.18.1+.
func (c *Client) WAT() wat.Service <span class="cov1" title="1">{
        return wat.NewService(c.core)
}</span>

// WLAN returns the WLAN configuration service.
func (c *Client) WLAN() wlan.Service <span class="cov1" title="1">{
        return wlan.NewService(c.core)
}</span>

// Tag service accessors - provide direct access to tag management services

// PolicyTag returns the Policy Tag service for policy tag management operations.
// This provides direct access to policy tag CRUD operations without going through WLAN service.
func (c *Client) PolicyTag() *wlan.PolicyTagService <span class="cov1" title="1">{
        return wlan.NewPolicyTagService(c.core)
}</span>

// RFTag returns the RF Tag service for RF tag management operations.
// This provides direct access to RF tag CRUD operations without going through RF service.
func (c *Client) RFTag() *rf.RFTagService <span class="cov1" title="1">{
        return rf.NewRFTagService(c.core)
}</span>

// SiteTag returns the Site Tag service for site tag management operations.
// This provides direct access to site tag CRUD operations without going through Site service.
func (c *Client) SiteTag() *site.SiteTagService <span class="cov1" title="1">{
        return site.NewSiteTagService(c.core)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
